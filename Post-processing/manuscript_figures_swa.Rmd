---
title: "Orca Silent Failures, Companion to Manuscript"
author: "Callum Mole"
date: "23/04/2020"
output: html_document
---


```{r Load preliminaries, include=FALSE, warning=FALSE}

library("tidyverse")
library("brms")
library("rstan")
library("tidybayes")
library("wesanderson")
library("cowplot")
library(latex2exp)
library(bayestestR)
library(grid)
library(zoo)

#blue and red from matplotlib tab10 default color cycle.
#red = #d62728
#blue = #1f77b4
cogload_cols = c("#1f77b4","#d62728")

#balanced colours are, in order of high to low severity:
#cmap = cm.get_cmap('tab10')
#rgbas = cmap([6,1,2,4]
#pink = #e377c2
#orange = #ff7f0e
#green = #2ca02c
#purple = #9467bd
balanced_cols = c("#e377c2","#ff7f0e","#2ca02c","#9467bd")

#for noload plots
pred_col = "grey60"
data_col = "black"


#add theme here
theme_orca <- theme(text = element_text(family = "sans", size = 10),
                    axis.text = element_text(family = "sans", size = 8),
                    axis.title = element_text(family = "sans", size = 10),
                    ) 

text_multiplier <- ggplot2:::.pt
ansize = 8/text_multiplier
pred_col = "grey60"


```


```{r, load data}



setwd("C:/git_repos/Orca18_Analysis/Post-Processing/")

#load steergaze data


#steergazedata <- read_csv("../Data/Orca19_collated_steering.csv")  
#saveRDS(steergazedata, "../Data/Orca19_collated_steering.rds")
steergazedata <- readRDS("../Data/Orca19_collated_steering2.rds")  

steergazedata$autoflag<- plyr::mapvalues(steergazedata$autoflag, from = c("True", "False"), to = c("TRUE", "FALSE"))

steergazedata <- steergazedata %>% 
  rename(swv = swa) %>% 
  mutate(swa = swv * 90)

#mirror data
steergazedata <- steergazedata %>% 
  mutate(world_x_mirrored = if_else(bend == -1, world_x * -1, world_x),
         swa_mirrored = if_else(bend == -1, swa * -1, swa),
         swv_mirrored = if_else(bend == -1, swv * -1, swv),
         sb_mirrored = if_else(bend == -1, steeringbias * -1, steeringbias))



ttlc_from_offset <- function(b, w = 1.5, r = 80, v = 8){
  b = b / 180 * pi
  
  ttlc = sqrt(w*(2*r + sign(b)*w)/(abs(b)*r*v))
}

steergazedata <- steergazedata %>% 
  mutate(ttlc_onset = ttlc_from_offset(sab))

#add RT and disengage flag.
disengage_RT <- function(onsettime, timestamp_trial, autoflag){
  
  #pick first frame where autoflag == false, then take the timestamp and minus the onset_time
  auto_false <- which(autoflag == "FALSE")
  disengage_index <- first(auto_false)
  disengage_trialtime <- timestamp_trial[disengage_index]
  onset_time <- first(onsettime)
  RT <- disengage_trialtime - onset_time #can be negative
  return(RT)
  
}

#calculate RT
steergazedata <- steergazedata  %>% 
  group_by(ppid, sab, cogload, trialn) %>% 
  mutate(RT = disengage_RT(onsettime, timestamp_trial, autoflag),
         disengaged = ifelse(is.na(RT), 0, 1) #whether or not they actually took over.
  )

#create unique trial id
steergazedata <- steergazedata %>% 
  mutate(trialid = paste(ppid, cogload, trialn, sep = "_"))

steergazedata$cogload <- as.factor(steergazedata$cogload)


#rename cogload factors so that it ameks sense
steergazedata$cogload<- plyr::mapvalues(steergazedata$cogload, from = c("None", "Middle"), to = c("noload", "load"))


steergazedata <- steergazedata %>% 
  ungroup() %>% 
  mutate(ttlc_takeover = ttlc_onset - RT,
        premature = ifelse(RT <= 0, 1, 0),
        time_remaining = 15 - onsettime, 
        early = time_remaining - RT,
        ttlc_end_of_trial = ttlc_onset - time_remaining)
```

```{r, manuscript info}

motor_delay = 0

data_fromtakeover <- steergazedata %>% 
  ungroup() %>% 
  group_by(trialid) %>% 
  filter(timestamp_trial > (RT + onsettime - motor_delay)) %>% 
  filter(ppid != 13,
         premature == 0, disengaged == 1) %>% 
  mutate(timestamp_zero = timestamp_trial - timestamp_trial[1],
         f = seq(1:n()))

data_fromtakeover$cogload <- relevel(data_fromtakeover$cogload, "noload")
balanced_only <- filter(data_fromtakeover, design == "balanced")

```

```{r, }
library(EnvStats)

x = rlnorm(1000000)
xlog = log(x)

xlog_med = median(xlog)
xlog_mn = mean(xlog) #geometric mean of x
#xlog_geo= geoMean(xlog)
trans_med = exp(xlog_med)
trans_mn = exp(xlog_mn)

x_med = median(x)
x_mn = mean(x)
x_gmn = geoMean(x)



```

```{r, plotting data_fromtakeover}

exitters <- data_fromtakeover %>% 
  filter(abs(sb_mirrored) > 1.5) %>% 
  select(trialid) %>% 
  unique(.)

roll_lines <- balanced_only %>% 
  ungroup() %>% 
  group_by(cogload, ttlc_onset, f) %>% 
  summarise(medsb = median(sb_mirrored),
            medswa = median(swa_mirrored)) %>% 
  mutate(roll_sb = rollapply(medsb, 15, mean, align = "left", partial = TRUE),
         roll_swa = rollapply(medswa, 15, mean, align = "left", partial = TRUE)) #.1s rolling average
    

# New facet label names for dose variable
#balanced_only$to_factor <- factor(balanced_only$ttlc_onset, levels = c("1","2","3","4"))
#ttlc_onset.labs <- c("1.93 s", "4.21 s", "6.39 s", "8. 37 s")
#print(unique(balanced_only$ttlc_onset))
#names(ttlc_onset.labs) <- unique(balanced_only$ttlc_onset)

uniq <- balanced_only %>% 
  ungroup() %>% 
  arrange(ttlc_onset) %>% 
  select(ttlc_onset) %>% 
  unique(.)
dat_titles<- data.frame(
  label = c(" 1.93 s", "4.21 s", "6.38 s", "8.37 s"),
  ttlc_onset = uniq$ttlc_onset)

balanced_only <- filter(balanced_only, f <= 180)
roll_lines <- filter(roll_lines, f <= 180)

p_lpos <- ggplot(balanced_only, aes(x = f / 60, y = sb_mirrored, group = trialid, col = cogload)) +
  geom_line(alpha = .05) +
  coord_cartesian(xlim = c(0, 3), ylim = c(-2,2), clip= "off") +
  geom_hline(yintercept=  c(-1.5, 1.5), linetype = "dashed", color = "grey60") +
  scale_y_reverse() +
  geom_line(data = roll_lines, aes(x = f / 60, y = roll_sb, group = cogload), size = 1) +
  
  
  scale_color_manual(values = cogload_cols, labels =rev(c('SupAuto+ACMT', 'SupAuto')), guide = FALSE) + #scale_fill_manual(values = rev(cogload_cols)) + guides(fill = FALSE) +
  
  #facet laps, change facet border, and place legend
  ylab("Steering Bias (m)") + xlab("Time from Takeover (s)") +
  theme_classic() +
  #facet_wrap(~ttlc_onset, labeller = as_labeller(function(x)paste0((round(as.double(x),2)), " s"))) +
  facet_wrap(~ttlc_onset, labeller = as_labeller(function(x)return(""))) +
  #facet_wrap(~ttlc_onset, labeller = labeller(ttlc_onset = ttlc_onset.labs)) +
  theme(panel.border = element_blank(), 
       panel.background = element_blank(), 
       panel.grid = element_blank(),
       strip.background = element_blank(),
       legend.position = c(0.5, 0.55),
       legend.title = element_blank(),
       legend.direction = "horizontal",
       legend.background = element_blank(),
       legend.key.size = unit(.75,"line")) +
  theme_orca +
  geom_text(data = dat_titles, aes(x = 1.5, y = -Inf, label = label), inherit.aes = FALSE, size = ansize, vjust = 0, col = balanced_cols)
  
print(p_lpos)

p_swa <- ggplot(balanced_only, aes(x = f / 60, y = swa_mirrored, group = trialid, col = cogload)) +
  geom_line(alpha = .05) +
  coord_cartesian(xlim = c(0, 3), clip = "off") +
  
  geom_line(data = roll_lines, aes(x = f / 60, y = roll_swa, group = cogload), size = 1) +
  
  
  scale_color_manual(values = cogload_cols, labels =rev(c('SupAuto+ACMT', 'SupAuto'))) +
  
  #facet laps, change facet border, and place legend
  ylab(expression("Steering Wheel Angle ("*degree*")")) + xlab("Time from Takeover (s)") +
  theme_classic() +
  #facet_wrap(~ttlc_onset, labeller = as_labeller(function(x)paste0((round(as.double(x),2)), " s"))) +
  facet_wrap(~ttlc_onset, labeller = as_labeller(function(x)return(""))) +
  #facet_wrap(~ttlc_onset, labeller = labeller(ttlc_onset = ttlc_onset.labs)) +
  theme(panel.border = element_blank(), 
       panel.background = element_blank(), 
       panel.grid = element_blank(),
       strip.background = element_blank(),
       legend.position = c(0.5, 0.55),
       legend.title = element_blank(),
       legend.direction = "horizontal",
       legend.background = element_blank()) +
  theme_orca +
    geom_text(data = dat_titles, aes(x = 1.5, y = Inf, label = label), inherit.aes = FALSE, size = ansize, vjust = 0, col = balanced_cols)
  
print(p_swa)


measures_grid <- plot_grid(p_lpos, p_swa, ncol = 2, labels = c("A","B"), label_size = 12)
print(measures_grid)

ggsave("steering_measures_plt.png", plot = measures_grid, dev = "png", width = 18, height = 10, units = "cm", dpi = 300, type = "cairo")

ggsave("steering_measures_plt.eps", plot = measures_grid, dev = cairo_ps, width = 13.2, height = 8.5, units = "cm", dpi = 300)

```


```{r, correlations, fig.height = 3.5, fig.width=5.2}

swa_max_uncentred <- function(swa, swa_to){
  #returns max angle that is the top of the swa turn range
  centred = swa - swa_to #centres the array on the initial value
  i = which.max(abs(centred)) #finds the frame that has the biggest difference from the initial value
  return(as.double(swa[i])) #returns the raw SWA.
}

lim_range <- function(swa_uc, swa_to){
  #returns max angle capped at relevant limit
  diff = swa_uc - swa_to #takes the raw SWA diff within initial angle
  direc = sign(diff) 
  lim = 90*direc
  return(abs(lim - swa_to)) #how much angle movement they have until they reach the limit
}

frames_u = 120 #maximum steering angle in the 2 s after takeover
frames_l = 15 #.25 s

data_fromtakeover <- data_fromtakeover %>% 
  group_by(trialid) %>% 
  mutate(swa_to = first(swa_mirrored), #swa at first frame
        swa_max_uc = swa_max_uncentred(swa_mirrored[1:frames_u], swa_to),
        swa_max_idx = which.max(abs(swa_mirrored[1:frames_u]-swa_to)),
        swa_max_idx2 = which.max(abs(swa_mirrored-swa_to)),
        swa_max = max(abs(swa_mirrored[1:frames_u]-swa_to)),
        sb_mn = mean(sb_mirrored),
        sw_var = sd(swa))

#data_fromtakeover <- data_fromtakeover %>% 
#  group_by(trialid) %>% 
#  mutate(n = n())

ntrials <- length(unique(data_fromtakeover$trialid))

data_sb <- data_fromtakeover %>% 
  group_by(trialid) %>% 
  filter(f <= frames_u) %>% 
  summarise(SDLP = sd(steeringbias),
            sw_var = first(sw_var),
            sab = first(sab),
            ttlc_takeover = first(ttlc_takeover),
            cogload = first(cogload),
            sb_mn = first(sb_mn),
            rms = sqrt(mean((sb_mirrored^2))),
            ppid = first(ppid),
            design = first(design),
            swa_to = first(swa_mirrored), #swa at first frame
            swa_max_uc = swa_max_uncentred(swa_mirrored, swa_to),
            swa_max_idx = which.max(abs(swa_mirrored-swa_to)),
            swa_lim = lim_range(swa_max_uc, swa_to),
            swa_max = max(abs(swa_mirrored-swa_to)),
            dmax = max(abs(diff(swa_mirrored))),
            noinput = ifelse(dmax == 0, 1, 0),
            RT = first(RT),
            ttlc_onset = first(ttlc_onset),
            onsettime = first(onsettime),
            frames = n()) %>% 
  filter(frames > frames_l)

trials_included = length(unique(data_sb$trialid))
print(ntrials - trials_included) #number omitted
print( (ntrials - trials_included) / ntrials ) #number omitted
print(mean(data_sb$swa_max_idx/60))

ggplot(data = data_sb, aes(y = swa_max_uc, x = swa_to)) + geom_point(alpha = .2) +
  geom_abline(slope = 1, intercept = 0) +
  geom_hline(yintercept = c(-90,90))


ggplot(data_sb, aes(x = swa_max_idx / 60, y = swa_max)) +
  geom_point(alpha = .2)

ggplot(data = data_sb, aes(y = log(swa_max), x = log(ttlc_takeover))) + geom_point(alpha = .2) 
  #geom_abline(slope = 1, intercept = 0) +
  #geom_hline(yintercept = c(-90,90))

cor_table <- data_sb %>% 
  ungroup() %>% 
  summarise(dmax_r = cor.test(swa_max, dmax, method = "pearson")$estimate,
            dmax_p = cor.test(swa_max, dmax, method = "pearson")$p.value,
            swa_var_r = cor.test(swa_max, sw_var, method = "pearson")$estimate,
            swa_var_p = cor.test(swa_max, sw_var, method = "pearson")$p.value,
            SDLP_r = cor.test(swa_max, SDLP, method = "pearson")$estimate,
            SDLP_p = cor.test(swa_max, SDLP, method = "pearson")$p.value,
            rms_r = cor.test(swa_max, rms, method = "pearson")$estimate,
            rms_p = cor.test(swa_max, rms, method = "pearson")$p.value,
            RT_r = cor.test(swa_max, RT, method = "pearson")$estimate,
            RT_p = cor.test(swa_max, RT, method = "pearson")$p.value,
            sb_RT_r = cor.test(sb_mn, RT, method = "pearson")$estimate,
            sb_RT_p = cor.test(sb_mn, RT, method = "pearson")$p.value)


print(cor_table)

plot_trial <- function(df){
  trial= sample(unique(df$trialid), 1)
  ggplot(filter(df, trialid == trial), aes(x = f/ 60, y = swa_mirrored)) +
         geom_path() +
    geom_line(aes(y = swa_max_uc), col = "blue") +
    geom_line(aes(y = swa_to), col = "red") +
    geom_vline(aes(xintercept = swa_max_idx / 60), col = "green") +
    geom_vline(aes(xintercept = swa_max_idx2 / 60), col = "green") +
    geom_vline(aes(xintercept = 90 / 60), col = "grey") 
    
  
}

plot_trial(data_fromtakeover)
```

```{r, fit model}

data_sb <- mutate(data_sb, log_swamax = log(swa_max), log_ttake = log(ttlc_takeover))

data_sb <- filter(data_sb, noinput == 0) #there is one trial where the SWA doesn't change but the driver disengages


save_stancode <- function(form, dat, fam, priors = NA, mod = ""){
  if (is.na(priors)){
    sc <- make_stancode(form, dat, fam)  
  } else{
    sc <- make_stancode(form, dat, fam, priors)  
  }
  
  fn <- paste("stancode_",mod,".txt",sep="")
  filecon <- file(fn)
  writeLines(sc, filecon)
  close(filecon)

}


form3 <- bf(log_swamax ~ log_ttake * cogload + (1 + log_ttake * cogload | ppid)) #the interaction isn't that interpretable so let's omit it for now. TODO: see how much LOO-CV it reduces.
#form2 <- bf(log_swamax ~ log_ttake + cogload + (1 + log_ttake + cogload | ppid))

print(get_prior(form2, data_sb, family=gaussian()))
            
npp <- length(unique(dta_sb$ppid))
inits <- list(list(b = array(1, dim = 2), Intercept = 1, sd_1 = array(1, dim =3), z_1 = array(1, dim = c(3,npp)))) 

#tofit$cogload <- relevel(tofit$cogload, "noload")
save_stancode(form2, data_sb, gaussian(), mod = "m3")

m3 <-brm(data = data_sb, formula = form3, family = gaussian(),
               iter = 10000, cores = 4, refresh = 500, chains = 1, warmup = 1000)
#we fit the interaction term because

summary(m3)
pp_check(m3)
marginal_effects(m3)


save(m3, file  = 'model_swa_loglog.rda')

summary(m3)


form_loglink <- bf(swa_max ~ log_ttake * cogload + (1 + log_ttake * cogload | ppid)) #the interaction isn't that interpretable

fam <- brmsfamily("gaussian" , link = "log")
print(get_prior(form_loglink, data_sb, family=fam))

m_loglink <-brm(data = data_sb, formula = form_loglink, family = fam,
               iter = 10000, cores = 4, refresh = 500, chains = 1, warmup = 1000)


summary(m_loglink)
pp_check(m_loglink)

```

```{r, plotting raw}

load('model_swa.rda')

onesd = .683
onesd.l = .5 - (onesd/2)
onesd.u = .5 + (onesd/2)
twosd = .955
twosd.l = .5 - (twosd/2)
twosd.u = .5 + (twosd/2)


ttlc_take <- seq(.1, to = 13, by = .1)
log_ttake <- log(ttlc_take)
cogload <- c("noload")
pred_list <- expand_grid(log_ttake, cogload)
preds <- predict(m3, newdata=pred_list, summary=TRUE, allow_new_levels = TRUE, probs = c(twosd.l, onesd.l, onesd.u, twosd.u)) %>% 
  cbind(pred_list) %>%
  group_by(log_ttake, cogload) %>% 
  mutate(Estimate = mean(Estimate),
         Q2.25 = min(Q2.25),
         Q15.85 = min(Q15.85),
         Q84.15 = min(Q84.15),
         Q97.75 = max(Q97.75))


plot_data <- data_sb %>% 
   filter(design == "balanced") %>% 
   ungroup()
#plot no load for paper.
p_raw_max <- ggplot(filter(data_sb, cogload == "noload"), aes(x = ttlc_takeover, y = swa_max)) +
  
  
  geom_ribbon(data = preds, aes(x = exp(log_ttake), ymin = exp(Q2.25), ymax = exp(Q97.75)), fill = pred_col, col = NA, alpha = .1, inherit.aes = F) + #99% band
  geom_ribbon(data = preds, aes(x = exp(log_ttake), ymin = exp(Q15.85), ymax = exp(Q84.15)), fill = pred_col, alpha = .3, inherit.aes = F) + #50% band
  geom_line(data = preds, aes(x = exp(log_ttake), y = exp(Estimate)), col = pred_col, size = 1.5, inherit.aes = F, alpha = 1) + #mean 
  
  geom_point(data = filter(data_sb, cogload == "noload", design == "random"), aes(x = ttlc_takeover, y= swa_max), alpha = .25, col = data_col, size = 1) + #raw data
    geom_point(data = filter(plot_data, cogload == "noload"), aes(x = ttlc_takeover, y= swa_max, col = factor(ttlc_onset)), alpha = .25, size = 1) + #coloured 
  scale_colour_manual(values = balanced_cols, guide = F) +
  xlab(expression("TTLC"["Takeover"]*" (s)")) + ylab(expression("SWA"["Max"]*" "*degree)) +
  theme_classic() +
  theme_orca +
  coord_cartesian(xlim = c(0,8), ylim = c(0,90))
  
  
print(p_raw_max)


leg_v = .5 #vertical spacing
leg_b = -.5 #starting bottom
leg_l = -1.5 #left align
leg_h = .2 #space between dot and text

p_log_max <- ggplot(filter(data_sb, cogload == "noload"), aes(x = log(ttlc_takeover), y = log(swa_max))) +
  
  geom_ribbon(data = preds, aes(x = log_ttake, ymin = Q2.25, ymax = Q97.75), fill = pred_col, col = NA, alpha = .1, inherit.aes = F) + #99% band
  geom_ribbon(data = preds, aes(x = log_ttake, ymin = Q15.85, ymax = Q84.15), fill = pred_col, alpha = .3, inherit.aes = F) + #50% band
  geom_line(data = preds, aes(x = log_ttake, y = Estimate), col = pred_col, size = 1.5, inherit.aes = F, alpha = 1) + #mean 
  
  geom_point(data = filter(data_sb, cogload == "noload", design == "random"), aes(x = log(ttlc_takeover), y= log(swa_max)), alpha = .25, col = data_col, size = 1) + #raw data
    geom_point(data = filter(plot_data, cogload == "noload"), aes(x = log(ttlc_takeover), y= log(swa_max), col = factor(ttlc_onset)), alpha = .25, size = 1) + #coloured 
  scale_colour_manual(values = balanced_cols, guide = F) +
  xlab(expression("Log(TTLC"["Takeover"]*" (s) )")) + ylab(expression("Log(SWA"["Max"]*degree*")")) +
  theme_classic() +
  coord_cartesian(xlim = c(-2, 2.2), ylim = c(-1, 4.5)) +
  theme_orca +
  
  #custom legend
  annotate("point", x = leg_l, y= leg_b + (5*leg_v), col = balanced_cols[1], shape = 20, size = 2, alpa = .25) +
  annotate("text", x = leg_l+leg_h, y = leg_b + (5*leg_v), label = "1.93 s", hjust = 0, vjust = .5, size = ansize) +
  
  annotate("point", x = leg_l, y= leg_b + (4*leg_v), col = balanced_cols[2], shape = 20, size = 2, alpa = .25) +
  annotate("text", x = leg_l+leg_h, y = leg_b + (4*leg_v), label = "4.21 s", hjust = 0, vjust = .5, size = ansize) +
  
  annotate("point", x = leg_l, y= leg_b + (3*leg_v), col = balanced_cols[3], shape = 20, size = 2, alpa = .25) +
  annotate("text", x = leg_l+leg_h, y = leg_b + (3*leg_v), label = "6.39 s", hjust = 0, vjust = .5, size = ansize) +
  
  annotate("point", x = leg_l, y= leg_b + (2*leg_v), col = balanced_cols[4], shape = 20, size = 2, alpa = .25) +
  annotate("text", x = leg_l+leg_h, y = leg_b + (2*leg_v), label = "8.37 s", hjust = 0, vjust = .5, size = ansize) +
  
  annotate("point", x = leg_l, y= leg_b + (leg_v), col = pred_col, shape = 20, size = 2, alpa = .25) +
  annotate("text", x = leg_l+leg_h, y = leg_b + (leg_v), label = "Non-Repeated", hjust = 0, vjust = .5, size = ansize) 
  
  
print(p_log_max)


p_log_max_load <- ggplot(filter(data_sb, cogload == "load"), aes(x = log(ttlc_takeover), y = log(swa_max))) +
  theme_classic() +
  geom_ribbon(data = preds, aes(x = log_ttake, ymin = Q2.25, ymax = Q97.75), fill = cogload_cols[2], col = NA, alpha = .1, inherit.aes = F) + #99% band
  geom_ribbon(data = preds, aes(x = log_ttake, ymin = Q15.85, ymax = Q84.15), fill = cogload_cols[2], alpha = .3, inherit.aes = F) + #50% band
  geom_line(data = preds, aes(x = log_ttake, y = Estimate), col = cogload_cols[2], size = 1, inherit.aes = F, alpha = 1) + #mean 
  geom_point(alpha = .25, size = .5,col =  cogload_cols[2]) +
  xlab("") + ylab("") +
  coord_cartesian(xlim = c(-2, 2.2), ylim = c(-1, 4.5)) +
  theme(axis.text=element_blank(), axis.ticks = element_blank(),
       panel.border = element_rect(colour = "black", fill=NA, size=.5),
        axis.title = element_text(size = 8),
       legend.background = element_blank(),
       panel.background = element_blank(),
       plot.background = element_rect(fill = "transparent",colour = NA)) 
  
p_log_max_load
  
#Maybe put the load version in appendix.
#plot.with.inset <-
#  ggdraw() +
#  draw_plot(p_log_max) +
#  draw_plot(p_log_max_load, x = 0.1, y = .1, width = .4, height = .4)

swamax_grid <- plot_grid(p_raw_max, p_log_max, ncol = 2, labels = c("A","B"), label_size = 12)



print(swamax_grid)

#ggsave("swa_max.png", plot = swamax_grid, dev = "png", width = 18, height = 6, units = "cm", dpi = 300, type = "cairo")
#ggsave("swa_max_raw_preds.eps", plot = swamax_grid, dev = cairo_ps, width = 13.2, height = 6, units = "cm", dpi = 300)


```

```{r, predictive plots}


onesd = .683
onesd.l = .5 - (onesd/2)
onesd.u = .5 + (onesd/2)
twosd = .955
twosd.l = .5 - (twosd/2)
twosd.u = .5 + (twosd/2)



ttlc_take <- seq(.1, to = 13, by = .1)
log_ttake <- log(ttlc_take)
#ppid <- c(1:12, 14:20)
cogload <- c("noload","load")
pred_list <- expand_grid(log_ttake, cogload)
preds <- predict(m3, newdata=pred_list, summary=TRUE, allow_new_levels = TRUE, probs = c(twosd.l, onesd.l, onesd.u, twosd.u)) %>% 
  cbind(pred_list) %>%
  group_by(log_ttake, cogload) %>% 
  mutate(Estimate = mean(Estimate),
         Q2.25 = min(Q2.25),
         Q15.85 = min(Q15.85),
         Q84.15 = min(Q84.15),
         Q97.75 = max(Q97.75))
  


#preds$cogload <- relevel(preds$cogload, "noload")  
  
loglog <- ggplot(preds, aes(x = log_ttake, group = cogload, col = cogload)) +
  
  geom_ribbon(aes(ymin = Q2.25, ymax = Q97.75, fill = cogload), col = NA, alpha = .1) + #99% band
  geom_ribbon(aes(ymin = Q15.85, ymax = Q84.15, fill = cogload), col = NA, alpha = .3) + #50% band  

  geom_line(aes(y = Estimate, col = cogload), size = 1) +  #mean
  theme_classic() +
  scale_color_manual(values = rev(cogload_cols), labels = c('SupAuto+ACMT', 'SupAuto'), guide = F) +scale_fill_manual(values = rev(cogload_cols), guide = F)+
  guides(color = guide_legend(reverse = TRUE)) +
  theme(legend.position = c(0.35, .3),
        legend.title = element_blank(),
        legend.background = element_blank(),
        legend.key.size = unit(.75,"line")) +
  xlab(expression("Log(TTLC"["Takeover"]*" (s) )")) + ylab(expression("Log(SWA"["Max"]*degree*")")) +
  
  coord_cartesian(xlim = c(-2, 2.2), ylim = c(-1, 4.5)) +
  theme_orca
  
print(loglog)
  
raw_preds <- ggplot(preds, aes(x = exp(log_ttake), group = cogload, col = cogload)) +
  theme_classic() +
  geom_ribbon(aes(ymin = exp(Q2.25), ymax = exp(Q97.75), fill = cogload), col = NA, alpha = .1) + #99% band
  geom_ribbon(aes(ymin = exp(Q15.85), ymax = exp(Q84.15), fill = cogload), col = NA, alpha = .3) + #50% band  

  geom_line(aes(y = exp(Estimate), col = cogload), size = 1) +  #mean
  scale_color_manual(values = rev(cogload_cols), labels = c('SupAuto+ACMT', 'SupAuto'), guide = F) +scale_fill_manual(values = rev(cogload_cols), guide = F)+
  coord_cartesian(xlim = c(0,8), ylim = c(0,90)) +
  theme_orca +
  theme(legend.position = c(0.8, .8),
        legend.title = element_blank(),
        legend.background = element_blank(),
        legend.key.size = unit(.75,"line")) +
  xlab(expression("TTLC"["Takeover"]*" (s)")) + ylab(expression("SWA"["Max"]*degree)) 

print(raw_preds)

#plot.with.inset <-
#  ggdraw() +
#  draw_plot(loglog) +
#  draw_plot(raw_inset, x = 0.15, y = .2, width = .4, height = .45)

#print(plot.with.inset)


steering_model_res <- plot_grid(p_raw_max, p_log_max, raw_preds, loglog, ncol = 2, nrow = 2, labels = c("A","B","C","D"), label_size = 12)
print(steering_model_res)
ggsave("swa_graphed_results.png", plot = steering_model_res, dev = "png", width = 13.2, height = 10, units = "cm", dpi = 300, type = "cairo")
ggsave("swa_graphed_results.eps", plot = steering_model_res, dev = cairo_ps, width = 13.2, height = 10, units = "cm", dpi = 300)

```


```{r, model coefficinets}

pars = c("b_Intercept", "b_log_ttake", "b_cogloadload", "b_log_ttake:cogloadload",
         "sd_ppid__Intercept", "sd_ppid__log_ttake", "sd_ppid__cogloadload", "sd_ppid__log_take:cogloadload")
draws_coef <- m3 %>% 
  posterior_samples(., pars = pars) %>% 
  gather(key = "b", value = "estimate") %>% 
  group_by(b) %>% 
  mean_hdi() %>% 
  mutate(b = fct_relevel(b, "b_Intercept", "b_log_ttake", "b_cogloadload", "b_log_ttake:cogloadload",
                         "sd_ppid__Intercept", "sd_ppid__log_ttake", "sd_ppid__cogloadload", "sd_ppid__log_take:cogloadload")) %>% 
  arrange(b)

print(draws_coef)

print(exp(draws_coef))

exp_coef <- exp(draws_coef[,2:4])
print(exp_coef)


p_coef <- m3 %>% 
  posterior_samples(., pars = c("b_cogloadload","b_log_ttake:cogloadload")) %>% 
  p_direction() 
#draws_plot <- draws_coef[2:nrow(draws_coef),]

#print(exp(draws_coef[3,2:4]))


#breaks = c(parse(text = TeX('$\\beta_{TT}$')),
#           parse(text = TeX('$\\beta_{L}$')),
#           parse(text = TeX('$\\beta_{TT \\times L}$')))

#forest <- ggplot() +
#  geom_pointintervalh(data = draws_plot,aes(y = reorder(b, desc(b)), x = estimate, xmin = .lower, xmax = .upper), col = #"black",fatten_point = 1, size = 1) +
#  theme_classic() +
#  geom_vline(xintercept = 0, linetype= "dashed", col = "grey80") +
#   scale_y_discrete(labels = rev(breaks))+
#   scale_x_continuous(breaks = c(-1, -.75, -.5, -.25, 0), labels = c("-1","-.75","-.5","-.25","0"))+
#  ylab("Coefficients") +
#  xlab("Estimate") +
#  theme_orca +
#  coord_cartesian(xlim=(c(-1, .2)))
  
  
#print(forest)


#effects_grid <- plot_grid(forest, plot.with.inset, ncol = 2, labels = c("A","B"), label_size = 12, rel_widths = #c(1,1.75))
#ggsave("swa_effects.png", plot = effects_grid, dev = "png", width = 18, height = 8, units = "cm", dpi = 300, type = "cairo")
#ggsave("swa_effects.eps", plot = effects_grid, dev = cairo_ps, width = 13.2, height = 6, units = "cm", dpi = 300)

```