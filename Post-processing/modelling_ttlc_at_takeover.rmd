---
title: 'Building a statistical model of reaction times to automation failures.'
author: "Callum Mole"
output:
  html_document:
    df_print: paged
  html_notebook:
    fig_caption: yes
  pdf_document:
    fig_caption: yes
  word_document:
    fig_caption: yes
---

## Introduction

This document steps through the statistical model building for takeover reaction times in a silent failure experiment, pre-reg can be found at https://osf.io/mydfw. We are primarily interested in how cognitive load affects reaction times at different levels of failure.

First we load the data.

```{r Load preliminaries, include=FALSE, warning=FALSE}

library("tidyverse")
library("brms")
library("rstan")
library("tidybayes")
library("wesanderson")
library("cowplot")
library(latex2exp)
library(bayestestR)

```

```{r, load data}


setwd("C:/git_repos/Orca18_Analysis/Post-Processing/")

#load steergaze data


#steergazedata <- read_csv("../Data/Orca19_collated_steering.csv")  
#saveRDS(steergazedata, "../Data/Orca19_collated_steering.rds")
steergazedata <- readRDS("../Data/Orca19_collated_steering.rds")  


steergazedata <- steergazedata %>% 
  rename(swv = swa) %>% 
  mutate(swa = swv * 90)

#mirror data
steergazedata <- steergazedata %>% 
  mutate(world_x_mirrored = if_else(bend == -1, world_x * -1, world_x),
         swa_mirrored = if_else(bend == -1, swa * -1, swa),
         swv_mirrored = if_else(bend == -1, swv * -1, swv),
         sb_mirrored = if_else(bend == -1, steeringbias * -1, steeringbias))



ttlc_from_offset <- function(b, w = 1.5, r = 80, v = 8){
  b = b / 180 * pi
  
  ttlc = sqrt(w*(2*r + sign(b)*w)/(abs(b)*r*v))
}

off = -5.72 / 180 * pi
rt = ttlc_from_offset(-0.52191351, r = 80)

myttlc <- function(w = 1.5, r = 80, v = 8){
  ttlc = (w / sin(v/r)) / v
}

off_tangent <- function(w=1.5,r =80, v = 8){
  ttlc = sqrt(w*(2*r+w) / (v^2))
}
rt = off_tangent()

mammar_zero <- function(w=1.5, r = 80, v = 8){
  off = v/r
  dlc = (r+w)*sin(off)-sqrt((r^2 - ((r+w)^2)*(cos(off)^2)))
  print(dlc)
  ttlc = dlc/v
}
bend_yr = 8/80
tots = 80+1.5
sqrt(80^2 - tots^2 * cos(bend_yr)^2)
sqrt(80^2 - (cos(bend_yr)^2 * tots^2))

tots*sin(bend_yr)
rt = myttlc()
rt = mammar_zero()

steergazedata <- steergazedata %>% 
  mutate(ttlc_calc = ttlc_from_offset(sab))

#add RT and disengage flag.
disengage_RT <- function(onsettime, timestamp_trial, autoflag){
  
  #pick first frame where autoflag == false, then take the timestamp and minus the onset_time
  auto_false <- which(autoflag == "FALSE")
  disengage_index <- first(auto_false)
  disengage_trialtime <- timestamp_trial[disengage_index]
  onset_time <- first(onsettime)
  RT <- disengage_trialtime - onset_time #can be negative
  return(RT)
  
}

#calculate RT
steergazedata <- steergazedata  %>% 
  group_by(ppid, sab, cogload, trialn) %>% 
  mutate(RT = disengage_RT(onsettime, timestamp_trial, autoflag),
         disengaged = ifelse(is.na(RT), 0, 1) #whether or not they actually took over.
  )

#create unique trial id
steergazedata <- steergazedata %>% 
  mutate(trialid = paste(ppid, cogload, trialn, sep = "_"))

steergazedata$cogload <- as.factor(steergazedata$cogload)


#rename cogload factors so that it ameks sense
steergazedata$cogload<- plyr::mapvalues(steergazedata$cogload, from = c("None", "Middle"), to = c("noload", "load"))





#we now have two data frames. "balanced_steerdata" and "random_steerdata"
data_RTs <- steergazedata  %>% 
  ungroup() %>% 
  group_by(ppid, cogload, trialn) %>% 
  summarize(RT = first(RT),
            disengaged = first(disengaged), #whether or not they actually took over.
            premature = ifelse(RT <= 0, 1, 0),
            sab = first(sab),
            onsettime = first(onsettime),
            design = first(design),
            simTTLC = first(simulated_ttlc),
            ttlc_onset = first(ttlc_calc),
            ttlc_takeover = ttlc_onset - RT,
            time_remaining = 15 - onsettime, 
            early = time_remaining - RT,
            ttlc_end_of_trial = ttlc_onset - time_remaining)

#data_RTs <- mutate(data_RTs, time_remaining = 15 - onsettime,
 #                  early = time_remaining - RT)
print(unique(data_RTs$ttlc_onset))

data_RTs <- data_RTs %>% mutate(log_ttake = log(ttlc_takeover), log_TR = log(time_remaining), log_tons = log(ttlc_onset))
data_RTs <- data_RTs %>% mutate(inv_ttake = 1/ttlc_takeover, inv_TET = 1/ttlc_end_of_trial, inv_tons = 1/ttlc_onset)
```


Let's plot a scatter plot to get an idea of the behaviour. We draw trend lines through the medians of each factor.

```{r scatter plots, echo=FALSE, message=FALSE, warning=FALSE}

#median data frame.
med_RTs <- data_RTs %>% 
  filter(design == "balanced", disengaged == 1) %>%
  group_by(ttlc_onset, cogload) %>% 
  summarise(inv_ttake = median(inv_ttake))

dodge <- position_dodge(width=0.1)  

p <- ggplot(filter(data_RTs, design == "balanced", ttlc_takeover > 0), aes(x = ttlc_onset, y= inv_ttake, colour = cogload, group = cogload)) +
  geom_point(alpha = .1, position = dodge) +
  geom_line(data = med_RTs, size = 1, position = dodge) +
  geom_point(data = med_RTs, size =2, position = dodge) +
  scale_colour_brewer(palette = "Set1")

print(p)
#ggsave('meds.png', p,  device="png", width=18, height= 8.5, units = "cm", dpi=300, type="cairo")

#steergazedata %>% 
#  ungroup() %>% 
#  filter(design == "random") %>% 
#  summarise(min(autofile_i))
  
```



```{r load and plot random ttlc_takoever, echo=FALSE, message=FALSE, warning=FALSE}



ticks <- data_RTs %>% 
  filter(design == "balanced") %>% 
  ungroup() %>% 
  mutate(ttlc_onset = round(ttlc_onset, digits = 1)) %>% 
  select(ttlc_onset) %>% 
  unique(.)
  
#median data frame.
med_RTs <- data_RTs %>% 
  filter(design == "balanced", disengaged == 1) %>%
  group_by(ttlc_onset, cogload) %>% 
  summarise(ttlc_takeover = median(ttlc_takeover))




p <- ggplot(filter(data_RTs, premature == 0, disengaged == 1), aes(x = ttlc_onset, y= ttlc_takeover, colour = cogload, group = cogload)) +
  geom_point(alpha = .1, position = dodge) +
  geom_line(data = med_RTs, size = 1, position = dodge) +
  geom_point(data = med_RTs, size =2, position = dodge) +
  scale_colour_brewer(palette = "Set1") +
  theme_classic() +
  scale_x_continuous(breaks = ticks$ttlc_onset, labels = ticks$ttlc_onset) +
  coord_fixed(ratio = 1) +
  geom_abline(intercept = 0, slope = 1)

print(p)

#ggsave('meds_full.png', p,  device="png", width=18, height= 8.5, units = "cm", dpi=300, type="cairo")

#max(data_RTs$RT)#

#data_RTs <- mutate(data_RTs, time_remaining = 15 - onsettime,
 #                  early = time_remaining - RT)

#head(filter(data_RTs, early < .1))

#ggplot(data_RTs, aes(x = time_remaining, y = time_remaining - RT)) + geom_point()

```


```{r, plot density}

p_dens <- ggplot(filter(data_RTs, design == "balanced", premature == 0, disengaged == 1), aes(x = ttlc_takeover, group = cogload, fill = cogload)) +
  geom_histogram(alpha = .5, position = "identity", bins = 60) +
  
  scale_fill_manual(values = rev(wes_palette("BottleRocket2",n=2))) +
  xlab(expression("ttlc"["takeover"]*" (s)")) + theme_classic() + 
  facet_wrap(~sab, scales = "free_y") 
print(p_dens)

ggsave('distribution_ttlc_takeover.png', p_dens,  device="png", width=18, height= 10, units = "cm", dpi=300, type="cairo")


```

```{r, plot variance}

#variance data frame.
var_RTs <- data_RTs %>% 
  filter(disengaged == 1, premature == 0, design == "balanced") %>% 
  group_by(ppid, ttlc_onset, cogload) %>% 
  summarise(std = sd(ttlc_takeover))

med_var <- var_RTs %>% 
  ungroup() %>% 
  group_by(ttlc_onset, cogload) %>% 
  summarise(med = median(std))

head(var_RTs)

#dodge <- position_dodge(width=0.1)  
p_var <- ggplot(data = var_RTs, aes(x =  log(ttlc_onset), y= log(std), colour = cogload, group = cogload)) +
  geom_point(alpha = .2)
  
#  geom_point(data = med_var, aes(x = log(ttlc_onset), y= log(med), colour = cogload, group = cogload), alpha = .3, size = 3) +
#  geom_line(data = med_var, aes(x = log(ttlc_onset), y = log(med), colour = cogload, group = cogload)) +
#  scale_colour_brewer(palette = "Set1") 
  #ylim(0,1.5) + theme_classic()

p_var_dist <- ggplot(data = var_RTs, aes(x = log(std), fill = cogload, group = cogload)) +
  geom_histogram(alpha = .2)+
  facet_wrap(~ttlc_onset)


print(p_var_dist)

print(p_var)

ggplot(data = var_RTs, aes(x = ttlc_onset, y = std, colour = cogload, group = cogload)) +
  geom_point(alpha = .5)

#ggsave('var.png', p_var,  device="png", width=18, height= 8.5, units = "cm", dpi=300, type="cairo")

```



```{r, check cogload relationship across ttlc}

meds <- data_RTs %>% 
  filter(design == "balanced") %>% 
  group_by(ppid, ttlc_onset, cogload) %>% 
  summarise(medRT = median(ttlc_takeover))


head(meds)
cogload_diff <- meds %>% 
  group_by(ppid, ttlc_onset) %>% 
  summarise(diff = medRT[1] - medRT[2],
            val = diff/medRT[2],
            noload = medRT[2]) 

med_trend <- cogload_diff %>% group_by(ttlc_onset) %>% summarise(meddiff = median(diff, na.rm = TRUE))

ggplot(cogload_diff, aes(x = val)) + 
  geom_histogram(alpha = .5) 

ggplot(cogload_diff, aes(x = noload, y = diff, group = ppid, colour = factor(ppid))) + 
  geom_point(alpha = .5) +
  #geom_line(data = med_trend, aes(x = ttlc_calc, y = meddiff))
  geom_line(alpha = .7)


```


```{r, check inverse relationship}

data_RTs <- data_RTs %>% mutate(inv_RT = 1/RT, inv_TR = 1/time_remaining, inv_ttlc = 1/ttlc_onset)
ggplot(filter(data_RTs, premature == 0), aes(x =ttlc_onset, y= RT, colour = cogload, group = cogload)) +
  geom_point(alpha = .8) +
  facet_wrap(~ppid)



```

```{r, checking prior for 0+intercept}

data_RTs_cens <- data_RTs %>%
  filter(premature == 0 | is.na(premature)) %>% #takeovers before onset are uncontrolled
  mutate(censored = ifelse(is.na(ttlc_takeover), -1,
                           ifelse(ttlc_takeover < ttlc_end_of_trial, -1, 0)))

data_RTs_cens$cogload <- relevel(data_RTs_cens$cogload, "noload")
data_RTs_cens <- filter(data_RTs_cens, ppid != 13) #13 moves the wheel pretty much every trial before they should do, so is not following instructions and should be excluded.

bf_intc <- bf(ttlc_takeover ~ 0 + intercept + ttlc_onset, sigma ~ 0 + intercept + ttlc_onset)
fam <- brmsfamily("gaussian", link_sigma = "identity")
print(get_prior(bf_intc, data =data_RTs_cens, family=fam))

myprior = c(set_prior("normal(0,5)", class="b", coef = "intercept"),
            set_prior("gamma(1,.5)", class="b", coef = "intercept", dpar = "sigma"),
            set_prior("normal(0,5)", class="b", coef = "ttlc_onset"),
            set_prior("normal(0,5)", class="b", coef = "ttlc_onset", dpar = "sigma"))



hist(rgamma(1000, shape = 1, scale = 1/.5))


save_stancode(bf_intc, data_RTs_cens, fam, priors = myprior, mod = "m_test")

m_test <- brm(data = data_RTs_cens, formula = bf_intc,
                family = fam, prior = myprior, #inits = inits9,
                iter = 10000, cores = 4, refresh = 500, chains = 1, warmup = 1000)

#inits9 <- list(list(b_sigma = array(0, dim = 3), Intercept_sigma = 1, sd_2 = array(1, dim =3), z_2 = array(1, dim = c(3,npp)))) #list must be size of the number of
```



```{r checking best response distribution, echo=FALSE, message=FALSE, warning=FALSE, eval = FALSE}

##############################

#TODO: Tidy section. The incremental model comparison can be in it's own section.
#The final model, m10.gauss with log link on sigma, should have it's own cell where the priors are also graphed.
# this is m9.gauss.

#############################

tofit_trim <- filter(data_RTs, premature == 0, disengaged == 1) #include the NA responses
#use non-disengaged as left-censored
data_RTs_cens <- data_RTs %>%
  filter(premature == 0 | is.na(premature)) %>% #takeovers before onset are uncontrolled
  mutate(censored = ifelse(is.na(ttlc_takeover), -1,
                           ifelse(ttlc_takeover < ttlc_end_of_trial, -1, 0)))

data_RTs_cens$cogload <- relevel(data_RTs_cens$cogload, "noload")
data_RTs_cens <- filter(data_RTs_cens, ppid != 13) #13 moves the wheel pretty much every trial before they should do, so is not following instructions and should be excluded.

bf0 <- bf(ttlc_takeover ~ 1 + ttlc_onset * cogload)

m0.gauss <- brm(data = tofit_trim, formula = bf0,
                family = gaussian(),
                iter = 5000, cores = 4, refresh = 500, chains = 1, warmup = 1000)

#of course it misses the point
summary(m0.gauss)
pp_check(m0.gauss)

bf1 <- bf(ttlc_takeover ~ 1 + ttlc_onset * cogload + (1 + ttlc_onset * cogload | ppid))

m1.gauss <- brm(data = tofit_trim, formula = bf1,
                family = gaussian(),
                iter = 5000, cores = 4, refresh = 500, chains = 1, warmup = 1000)

summary(m1.gauss)
pp_check(m1.gauss)

#random effects is better, but variance changes per person and also with ttlc
loo(m0.gauss, m1.gauss)

bf2 <- bf(ttlc_takeover ~ 1 + ttlc_onset * cogload + (1 + ttlc_onset * cogload | ppid), sigma ~ (1 | ppid))
m2.gauss <- brm(data = tofit_trim, formula = bf2,
                family = gaussian(),
                iter = 5000, cores = 4, refresh = 500, chains = 1, warmup = 1000)

summary(m2.gauss)
pp_check(m2.gauss)




loo(m0.gauss, m1.gauss, m2.gauss)


bf3 <- bf(ttlc_takeover ~ 1 + ttlc_onset * cogload + (1 + ttlc_onset * cogload | ppid), sigma ~ ttlc_onset + (1 | ppid))
m3.gauss <- brm(data = tofit_trim, formula = bf3,
                family = gaussian(),
                iter = 5000, cores = 4, refresh = 500, chains = 1, warmup = 1000)

summary(m3.gauss)
pp_check(m3.gauss)


loo(m0.gauss, m1.gauss, m2.gauss, m3.gauss)


bf4 <- bf(ttlc_takeover ~ 1 + ttlc_onset * cogload + (1 + ttlc_onset * cogload | ppid), sigma ~ ttlc_onset + cogload + (1 | ppid))
m4.gauss <- brm(data = tofit_trim, formula = bf4,
                family = gaussian(),
                iter = 5000, cores = 4, refresh = 500, chains = 1, warmup = 1000)

summary(m4.gauss)
pp_check(m4.gauss)


loo(m0.gauss, m1.gauss, m2.gauss, m3.gauss, m4.gauss)


bf5 <- bf(ttlc_takeover ~ 1 + ttlc_onset * cogload + (1 + ttlc_onset * cogload | ppid), sigma ~ ttlc_onset * cogload + (1 | ppid))
m5.gauss <- brm(data = tofit_trim, formula = bf5,
                family = gaussian(),
                iter = 5000, cores = 4, refresh = 500, chains = 1, warmup = 1000)

summary(m5.gauss)
pp_check(m5.gauss)


loo(m0.gauss, m1.gauss, m2.gauss, m3.gauss, m4.gauss, m5.gauss)


bf6 <- bf(ttlc_takeover ~ 1 + ttlc_onset * cogload + (1 + ttlc_onset * cogload | ppid), sigma ~ (1 + ttlc_onset * cogload  | ppid))
m6.gauss <- brm(data = tofit_trim, formula = bf6,
                family = gaussian(),
                iter = 10000, cores = 4, refresh = 500, chains = 1, warmup = 1000)

summary(m6.gauss)
pp_check(m6.gauss)


loo(m0.gauss, m1.gauss, m2.gauss, m3.gauss, m4.gauss, m5.gauss, m6.gauss)


#now for censoring and truncation.
#truncation at ttlc_onset
#y1|cens(censored) + trunc(lb = lb, ub = ub)


         
bf7 <- bf(ttlc_takeover | trunc(ub = ttlc_onset) + cens(censored) ~ 1 + ttlc_onset * cogload + (1 + ttlc_onset * cogload | ppid), sigma ~ ttlc_onset + (1  | ppid))


m7.gauss <- brm(data = data_RTs_cens, formula = bf7,
                family = gaussian(),
                iter = 10000, cores = 4, refresh = 500, chains = 1, warmup = 1000)

save(m7.gauss, file = 'm7.gauss.rda')
#can i do this with an identity link to sigma? 
summary(m7.gauss)
pp_check(m7.gauss)

bf8 <- bf(ttlc_takeover | trunc(ub = ttlc_onset) + cens(censored) ~ 1 + ttlc_onset * cogload + (1 + ttlc_onset * cogload | ppid), sigma ~ 1 + ttlc_onset * cogload + (1  | ppid))

fam <- brmsfamily("gaussian", link_sigma = "identity")

save_stancode(bf8, data_RTs_cens, fam, priors = myprior, mod = "m8.gauss")
print(get_prior(bf8, data =data_RTs_cens, family=fam, prior = myprior))
#init_f <- function () list(b_sigma = max(0.5,rnorm(1, 3, 1)), Intercept_sigma =  max(0.5,rnorm(1, 3, 1)))

inits <- list(list(b_sigma = array(0, dim = 3), Intercept_sigma = 1, sd_2 = array(1, dim =1), z_2 = array(1, dim = c(1,20)), Z_2_sigma_1 = 1)) #list must be size of the number of chains.

myprior = c(set_prior("cauchy(0,5)", class="b", dpar = "sigma"),
            set_prior("cauchy(0,5)", class="Intercept", dpar = "sigma"),
            set_prior("cauchy(0,5)", class="sd", dpar = "sigma"))
            


#sigma needs to be positive, but it's multiplied by the centred means (which can be negative). To remove the influence on centred means we set b_sigma to zero, and all other variables that contribute to sigma initialisation to 1 (or positive functions)
#see make_stancode
#print(make_stancode(bf8, data_RTs_cens, family = gaussian(), prior = myprior))

m8.gauss <- brm(data = data_RTs_cens, formula = bf8,
                family = fam, prior = myprior, inits = inits,
                iter = 10000, cores = 4, refresh = 500, chains = 1, warmup = 1000)

save(m8.gauss, file = 'm8.gauss.rda')
#can i do this with an identity link to sigma? 
summary(m8.gauss)
pp_check(m8.gauss)



###you really don't need this level of complexity.

#variable slopes on variance.
bf9 <- bf(ttlc_takeover | trunc(ub = ttlc_onset) + cens(censored) ~ 1 + ttlc_onset * cogload + (1 + ttlc_onset * cogload | ppid), sigma ~ 1 + log(ttlc_onset) + cogload + (1 + log(ttlc_onset) + cogload | ppid))

bf9.1 <- bf(ttlc_takeover | trunc(ub = ttlc_onset) + cens(censored) ~ 1 + ttlc_onset * cogload + (1 + ttlc_onset * cogload | ppid), sigma ~ 1 + log(ttlc_onset) * cogload + (1 + log(ttlc_onset) + cogload | ppid))

fam <- brmsfamily("gaussian", link_sigma = "log")

print(get_prior(bf9, data =data_RTs_cens, family=fam))
#init_f <- function () list(b_sigma = max(0.5,rnorm(1, 3, 1)), Intercept_sigma =  max(0.5,rnorm(1, 3, 1)))

save_stancode(bf9, data_RTs_cens, fam, priors = myprior, mod = "m9.gauss")

save_stancode <- function(form, dat, fam, priors = NA, mod = ""){
  if (is.na(priors)){
    sc <- make_stancode(form, dat, fam)  
  } else{
    sc <- make_stancode(form, dat, fam, priors)  
  }
  
  fn <- paste("stancode_",mod,".txt",sep="")
  filecon <- file(fn)
  writeLines(sc, filecon)
  close(filecon)
}


npp <- length(unique(data_RTs_cens$ppid))
inits9 <- list(list(b_sigma = array(0, dim = 2), Intercept_sigma = 1, sd_2 = array(1, dim =3), z_2 = array(1, dim = c(3,npp)))) #list must be size of the number of

inits9.1 <- list(list(b_sigma = array(0, dim = 3), Intercept_sigma = 1, sd_2 = array(1, dim =3), z_2 = array(1, dim = c(3,npp)))) #list must be size of the number of


#sigma needs to be positive, but it's multiplied by the centred means (which can be negative). To remove the influence on centred means we set b_sigma to zero, and all other variables that contribute to sigma initialisation to 1 (or positive functions)
#see make_stancode
#print(make_stancode(bf8, data_RTs_cens, family = gaussian(), prior = myprior))
myprior = c(set_prior("cauchy(0,1)", class="Intercept", dpar = "sigma"),
            set_prior("cauchy(0,1)", class="sd"))
            


m9.gauss <- brm(data = data_RTs_cens, formula = bf9,
                family = fam, prior = myprior, inits = inits9,
                iter = 10000, cores = 4, refresh = 500, chains = 1, warmup = 1000)

m9.1.gauss <- brm(data = data_RTs_cens, formula = bf9.1,
                family = fam, prior = myprior, inits = inits9.1,
                iter = 10000, cores = 4, refresh = 500, chains = 1, warmup = 1000)


summary(m9.gauss)
plot(m9.gauss)
save(m9.gauss, file = 'm9.gauss.rda')

m9.gauss[["prior"]]



#variable slopes on variance.
#it makes most sense for the link on sigma to be log, so zero values aren't predicted and the random effects
#over sigma are log-distributed. This increases the predicted variance at high TTLCs, but c'est la vie.
bf10 <- bf(ttlc_takeover | trunc(ub = ttlc_onset) + cens(censored) ~ 1 + ttlc_onset * cogload + (1 + ttlc_onset * cogload | ppid), sigma ~ 0 + intercept + ttlc_onset * cogload + (0 +intercept + ttlc_onset + cogload | ppid))

fam <- brmsfamily("gaussian", link_sigma = "log")

print(get_prior(bf10, data =data_RTs_cens, family=fam))
#init_f <- function () list(b_sigma = max(0.5,rnorm(1, 3, 1)), Intercept_sigma =  max(0.5,rnorm(1, 3, 1)))

save_stancode(bf10, data_RTs_cens, fam, priors = myprior, mod = "m10.gauss")




npp <- length(unique(data_RTs_cens$ppid))
#inits10 <- list(list(b_sigma = array(1, dim = 4), sd_2 = array(1, dim =4), z_2 = array(1, dim = c(4,npp)))) #list must be size of the number of



#sigma needs to be positive, but it's multiplied by the centred means (which can be negative). To remove the influence on centred means we set b_sigma to zero, and all other variables that contribute to sigma initialisation to 1 (or positive functions)
#see make_stancode
#print(make_stancode(bf8, data_RTs_cens, family = gaussian(), prior = myprior))
myprior = c(set_prior("normal(0,5)", class="b"),
            set_prior("gamma(1,.5)", class="b", coef = "intercept", dpar = "sigma"),
            set_prior("cauchy(0,1)", class="sd"))

            

m10.gauss <- brm(data = data_RTs_cens, formula = bf10,
                family = fam, prior = myprior, #inits = inits10,
                iter = 20000, cores = 4, refresh = 500, chains = 1, warmup = 1000)


summary(m10.gauss)
plot(m10.gauss)
pp_check(m10.gauss)
save(m10.gauss, file = 'm10.gauss.rda')

m10.gauss[["prior"]]
```
```{r, plot logsigma}
failures <-  seq(1, to = 13, by = .1)
logsig = (.6*log(failures))


inter <- failures^-.26
plot(exp(logsig))
plot(inter)
```




```{r, individual plot of predictive intervals}

load('m9.gauss.rda')
MOD <- m9.gauss

plot_ind_preds <- function(MOD){
  ttlc_onset <- seq(1, to = 13, by = .1)
  ppid <- c(1:12,14:20)
  cogload <- c("noload","load")
  pred_list <- expand_grid(ttlc_onset, cogload, ppid)
  preds <- predict(MOD, newdata=pred_list, summary=TRUE, probs = c(.005, 0.025, .25, .75, 0.975, .995)) %>% 
    cbind(pred_list) %>% 
    group_by(ppid, ttlc_onset) %>% 
    mutate(Estimate = mean(Estimate),
           Q0.5 = min(Q0.5),
           Q2.5 = min(Q2.5),
           Q25 = min(Q25),
           Q75 = max(Q75),
           Q97.5 = max(Q97.5),
           Q99.5 = max(Q99.5))
  
  pred_col = "turquoise4"
  data_col = "black"
  ind_ribbon <- ggplot(preds, aes(x = ttlc_onset)) +
    geom_line(aes(y = Q0.5), col = pred_col, alpha = .5, linetype = 2) +
      geom_line(aes(y = Q99.5), col = pred_col, alpha = .5, linetype = 2) +
      geom_line(aes(y = Q2.5), col = pred_col, alpha = .75, linetype = 2) +
      geom_line(aes(y = Q97.5), col = pred_col, alpha = .75, linetype = 2) +
      geom_line(aes(y = Q25), col = pred_col, alpha = 1, linetype = 2) +
      geom_line(aes(y = Q75), col = pred_col, alpha = 1, linetype = 2) +
      geom_line(aes(y = Estimate), col = pred_col) +
    facet_wrap(~ppid) +
    geom_point(data = data_RTs_cens, aes(x = ttlc_onset, y= ttlc_takeover), alpha = .5, col = data_col) +
    theme_classic() + ylim(-2,8) + xlab("ttlc takeover")
  
  print(ind_ribbon)  
  modstr = deparse(substitute(MOD))
  #ggsave(paste("pp_predictiveintervals_",modstr,".png",sep=""), plot = ind_ribbon, dev = "png", width = 18, height = 15, units = "cm", dpi = 300, type = "cairo")
  
}

plot_ind_preds(m9.gauss)




```

```{r, useful functions}




ttlc_calc <- seq(1, to = 15, by = .1)
ppid <- 1:20
cogload <- c("noload","load")
pred_list <- expand_grid(ttlc_calc, ppid, cogload)


create_predictions <- function(mod, condition_list){
  preds <- predict(mod, newdata=condition_list, summary=TRUE, probs = c(.005, 0.025, .25, .75, 0.975, .995), transform = "exp")     
  preds <- cbind(condition_list,preds) #add the condition values
  return(preds)
}

plot_ribbon <- function(dat, preds, fname, x, y){

  p <- ggplot(preds, aes_string(x = x)) +
    geom_line(aes(y = Q0.5), col = "blue", alpha = .2) +
    geom_line(aes(y = Q99.5), col = "blue", alpha = .2) +
    geom_line(aes(y = Q2.5), col = "blue", alpha = .5) +
    geom_line(aes(y = Q97.5), col = "blue", alpha = .5) +
    geom_line(aes(y = Q25), col = "blue", alpha = .75) +
    geom_line(aes(y = Q75), col = "blue", alpha = .75) +
    geom_line(aes(y = Estimate), col = "lightblue") +
    geom_point(data = dat, aes_string(x = x, y = y), alpha = .5, col = "black") +
  facet_wrap(~ppid) + ggsave(fname)
  
  return(p)
}


plot_hist <- function(mod, dat, x, xint){
  
  pred <- dat  %>%
  add_predicted_draws(mod)
  
  p <- ggplot(data = pred) +
  geom_histogram(aes_string(x = x), fill = "red", alpha = .4) +
  geom_histogram(aes(x = exp(.prediction)), alpha = .4, fill = "blue") +
  facet_wrap(~ttlc_calc, scales = "free_y") +
  geom_vline(aes_string(xintercept = xint)) +
  ylab("density")
  
  return(p)
}

```



```{r, fig1 - visualising predictive intervals for no load}

MOD <- m9.gauss


onesd = .683
onesd.l = .5 - (onesd/2)
onesd.u = .5 + (onesd/2)
twosd = .955
twosd.l = .5 - (twosd/2)
twosd.u = .5 + (twosd/2)



#avg_onset = mean(data_RTs_cens$onsettime)
#Fig1, overall predictive intervals.
ttlc_onset <- seq(.1, to = 17, by = .5)
#mean_censoring <- ttlc_onset - (15 - avg_onset)
#censor <- data.frame(ttlc_onset, mean_censoring)
cogload <- c("noload")
pred_list <- expand_grid(ttlc_onset, cogload)
preds <- predict(MOD, newdata=pred_list, summary=TRUE, allow_new_levels = TRUE, probs = c(twosd.l, onesd.l, onesd.u, twosd.u)) %>% 
  cbind(pred_list) %>%
  group_by(ttlc_onset) %>% 
  mutate(Estimate = mean(Estimate),
         Q2.25 = min(Q2.25),
         Q15.85 = min(Q15.85),
         Q84.15 = min(Q84.15),
         Q97.75 = max(Q97.75))


pred_col = "grey60"
data_col = "black"

ticks <- data_RTs %>% 
  filter(design == "balanced") %>% 
  ungroup() %>% 
  mutate(ttlc_onset_round = round(ttlc_onset, digits = 1)) %>% 
  select(ttlc_onset, ttlc_onset_round) %>% 
  unique(.)

#data_RTs %>% 
#  filter(design=="balanced", cogload == "noload", premature == 0) %>% 
#  group_by(ttlc_onset) %>% 
#  summarise(maxttlc = max(ttlc_takeover))



censors <- data_RTs_cens %>%
  ungroup() %>% 
  filter(cogload == "noload") %>% 
  mutate(xmin = ttlc_onset - .15,
         xmax = ttlc_onset + .15) %>% 
  select(ttlc_onset, onsettime, ttlc_end_of_trial, xmin, xmax) %>% 
  group_by(ttlc_onset, onsettime) %>% 
  summarise(mineot = min(ttlc_end_of_trial)) 
  #filter(ttlc_onset > 5 & ttlc_onset < 13)

onsets <- c(5.375, 6.5)
censor_lines <- lapply(onsets, function(x) ttlc_onset - (15 -x))


censor_m <- lm(mineot ~ poly(ttlc_onset,3), data = censors)

censor_predict <- stats::predict(object = censor_m, newdata = as.data.frame(ttlc_onset))


ribbon <- ggplot(preds, aes(x = ttlc_onset)) +
  geom_ribbon(aes(ymin = Q2.25, ymax = Q97.75), fill = pred_col, col = NA, alpha = .1) + #99% band
  geom_ribbon(aes(ymin = Q15.85, ymax = Q84.15), fill = pred_col, alpha = .3) + #50% band
  geom_line(aes(y = Estimate), col = pred_col, size = 2) + #mean
  
  
  #geom_line(aes(y = Q0.5), col = pred_col, alpha = .5, linetype = 2) +
  #geom_line(aes(y = Q99.5), col = pred_col, alpha = .5, linetype = 2) +
    
  #  geom_line(aes(y = Q2.5), col = pred_col, alpha = .75, linetype = 2) +
  #  geom_line(aes(y = Q97.5), col = pred_col, alpha = .75, linetype = 2) +
#    geom_line(aes(y = Q25), col = pred_col, alpha = 1, linetype = 2) +
  #  geom_line(aes(y = Q75), col = pred_col, alpha = 1, linetype = 2) +
  #  
  geom_point(data = filter(data_RTs_cens, cogload == "noload"), aes(x = ttlc_onset, y= ttlc_takeover), alpha = .25, col = data_col) + #raw data
  geom_abline(intercept = 0, slope = 1, linetype = 2, col = "grey40") + #1:1 line
  
  #geom_segment(data = censors, aes(x = ttlc_onset-.1, xend = ttlc_onset+.1, y = mineot, yend = mineot), size = 1, col = "red") +
  annotate("path", x = ttlc_onset, y = censor_lines[[1]], col = "grey20", linetype = "dotted") +
  #annotate("path", x = ttlc_onset, y = censor_lines[[2]], col = "grey20", linetype = "dotted") +
  annotate("point", x = 12.96, y= 3.33, col = "black", shape = 3) +
  #annotate("point", x = 10.42, y= 1.92, col = "black", shape = 3) +
  annotate("text", x = 12.7, y = 3.1, label = "Onset 5.38 s", hjust = 0, vjust = 0, size = 2) +
  #annotate("text", x = 10.2, y = 1.6, label = "Onset 6.5 s", hjust = 0, vjust = 0, size = 2) +
  annotate("text", x = 10.5, y = .5, label = expression("Example TTLC"["End of Trial"]), hjust = 0, vjust = 0, size = 2.5) +
  #geom_ribbon(data = censors, aes(x = ttlc_onset, ymin = -50, ymax = mineot), fill = "firebrick3") +
  #geom_point(data =filter(data_RTs_cens, cogload == "noload"), aes(x = ttlc_onset, y =ttlc_end_of_trial, col = onsettime)) +
  annotate("text", x = 13.5, y = 4.5, label = expression(mu), hjust = 0, vjust = 0, size = 2.5) +
  annotate("text", x = 13.25, y = 6.2, label = expression(mu*" + "*sigma), hjust = 0, vjust = 0, size = 2.5) +
  annotate("text", x = 13.2, y = 8.2, label = expression(mu*" + 2"*sigma), hjust = 0, vjust = 0, size = 2.5) +
  
  #annotate("point", x = 4.2, y= 4.2, col = "grey20", shape = 1) +
  annotate("path", x = 4.2, y= c(2.606,4.2), col = "grey20", linetype = "dotted") +
  #annotate("point", x = 4.2, y= 2.606, col = "grey20", shape = 1) +
  annotate("text", x = 4.3, y = 3.5, label = "RT", hjust = 0, vjust = 0, size = 2) +
  
  
  theme_classic() +
  xlab(expression("TTLC"["Failure"]*" (s)")) + ylab(expression("TTLC"["Takeover"]*" (s)")) + 
  coord_cartesian(xlim = c(0,13.25), ylim = c(-1,8)) +
  scale_x_continuous(breaks = ticks$ttlc_onset, labels = ticks$ttlc_onset_round)
  
  
 # scale_color_gradient(low = "firebrick3", high = "rosybrown1") + guides(color = FALSE) +
  
  #add custom legend 
  #geom_segment(aes(x = 15, xend = 15.5, y = -1, yend = -1), col = "rosybrown1", size = 1.5) +
  #geom_segment(aes(x = 15, xend = 15.5, y = -1.75, yend = -1.75), col = "firebrick3", size = 1.5) +
  #annotate("text", x = 15.75, y = 0, label = expression("TTLC"["End of Trial"]), size = 3) +
  #annotate("text", x = 16.25, y = -1, label = "Late onset", size = 2.5) +
  #annotate("text", x = 16.25, y = -1.75, label = "Early onset", size = 2.5) 

#ggplot(filter(data_RTs_cens, cogload == "noload")) +
#  geom_point(aes(x = ttlc_onset, y= ttlc_takeover), alpha = .25, col = data_col) + #raw data
#  geom_point(aes(x = ttlc_onset, y= ttlc_end_of_trial, col = factor(onsettime)), alpha = .25) + #raw data
#  facet_wrap(~ttlc_onset)
 


print(ribbon)
#ggsave("overall_predictiveintervals_ttlc_noload_log_nointer.png", plot = ribbon, dev = "png", width = 18, height = 8.5, units = "cm", dpi = 300, type = "cairo")
  



```

```{r, fig1 - visualising predictive intervals for load}

MOD <- m9.gauss


onesd = .683
onesd.l = .5 - (onesd/2)
onesd.u = .5 + (onesd/2)
twosd = .955
twosd.l = .5 - (twosd/2)
twosd.u = .5 + (twosd/2)



#avg_onset = mean(data_RTs_cens$onsettime)
#Fig1, overall predictive intervals.
ttlc_onset <- seq(.1, to = 17, by = .5)
#mean_censoring <- ttlc_onset - (15 - avg_onset)
#censor <- data.frame(ttlc_onset, mean_censoring)
cogload <- c("load")
pred_list <- expand_grid(ttlc_onset, cogload)
preds <- predict(MOD, newdata=pred_list, summary=TRUE, allow_new_levels = TRUE, probs = c(twosd.l, onesd.l, onesd.u, twosd.u)) %>% 
  cbind(pred_list) %>%
  group_by(ttlc_onset) %>% 
  mutate(Estimate = mean(Estimate),
         Q2.25 = min(Q2.25),
         Q15.85 = min(Q15.85),
         Q84.15 = min(Q84.15),
         Q97.75 = max(Q97.75))


pred_col = "grey60"
data_col = "black"

ticks <- data_RTs %>% 
  filter(design == "balanced") %>% 
  ungroup() %>% 
  mutate(ttlc_onset_round = round(ttlc_onset, digits = 1)) %>% 
  select(ttlc_onset, ttlc_onset_round) %>% 
  unique(.)


censors <- data_RTs_cens %>%
  ungroup() %>% 
  filter(cogload == "load") %>% 
  mutate(xmin = ttlc_onset - .15,
         xmax = ttlc_onset + .15) %>% 
  select(ttlc_onset, onsettime, ttlc_end_of_trial, xmin, xmax) %>% 
  group_by(ttlc_onset, onsettime) %>% 
  summarise(mineot = min(ttlc_end_of_trial)) 
  #filter(ttlc_onset > 5 & ttlc_onset < 13)

onsets <- c(5.375, 6.5)
censor_lines <- lapply(onsets, function(x) ttlc_onset - (15 -x))


censor_m <- lm(mineot ~ poly(ttlc_onset,3), data = censors)

censor_predict <- stats::predict(object = censor_m, newdata = as.data.frame(ttlc_onset))


ribbon <- ggplot(preds, aes(x = ttlc_onset)) +
  geom_ribbon(aes(ymin = Q2.25, ymax = Q97.75), fill = pred_col, col = NA, alpha = .1) + #99% band
  geom_ribbon(aes(ymin = Q15.85, ymax = Q84.15), fill = pred_col, alpha = .3) + #50% band
  geom_line(aes(y = Estimate), col = pred_col, size = 2) + #mean
  
  
  #geom_line(aes(y = Q0.5), col = pred_col, alpha = .5, linetype = 2) +
  #geom_line(aes(y = Q99.5), col = pred_col, alpha = .5, linetype = 2) +
    
  #  geom_line(aes(y = Q2.5), col = pred_col, alpha = .75, linetype = 2) +
  #  geom_line(aes(y = Q97.5), col = pred_col, alpha = .75, linetype = 2) +
#    geom_line(aes(y = Q25), col = pred_col, alpha = 1, linetype = 2) +
  #  geom_line(aes(y = Q75), col = pred_col, alpha = 1, linetype = 2) +
  #  
  geom_point(data = filter(data_RTs_cens, cogload == "load"), aes(x = ttlc_onset, y= ttlc_takeover), alpha = .25, col = data_col) + #raw data
  geom_abline(intercept = 0, slope = 1, linetype = 2, col = "grey40") + #1:1 line
  
  #geom_segment(data = censors, aes(x = ttlc_onset-.1, xend = ttlc_onset+.1, y = mineot, yend = mineot), size = 1, col = "red") +
  annotate("path", x = ttlc_onset, y = censor_lines[[1]], col = "grey20", linetype = "dotted") +
  #annotate("path", x = ttlc_onset, y = censor_lines[[2]], col = "grey20", linetype = "dotted") +
  annotate("point", x = 12.96, y= 3.33, col = "black", shape = 3) +
  #annotate("point", x = 10.42, y= 1.92, col = "black", shape = 3) +
  annotate("text", x = 12.7, y = 3.1, label = "Onset 5.38 s", hjust = 0, vjust = 0, size = 2) +
  #annotate("text", x = 10.2, y = 1.6, label = "Onset 6.5 s", hjust = 0, vjust = 0, size = 2) +
  annotate("text", x = 10.5, y = .5, label = expression("Example TTLC"["End of Trial"]), hjust = 0, vjust = 0, size = 2.5) +
  #geom_ribbon(data = censors, aes(x = ttlc_onset, ymin = -50, ymax = mineot), fill = "firebrick3") +
  #geom_point(data =filter(data_RTs_cens, cogload == "noload"), aes(x = ttlc_onset, y =ttlc_end_of_trial, col = onsettime)) +
  annotate("text", x = 13.5, y = 4.5, label = expression(mu), hjust = 0, vjust = 0, size = 2.5) +
  annotate("text", x = 13.25, y = 6.2, label = expression(mu*" + "*sigma), hjust = 0, vjust = 0, size = 2.5) +
  annotate("text", x = 13.2, y = 8.2, label = expression(mu*" + 2"*sigma), hjust = 0, vjust = 0, size = 2.5) +
  
  theme_classic() +
  xlab(expression("TTLC"["Failure"]*" (s)")) + ylab(expression("TTLC"["Takeover"]*" (s)")) + 
  coord_cartesian(xlim = c(0,13.25), ylim = c(-1,8)) +
  scale_x_continuous(breaks = ticks$ttlc_onset, labels = ticks$ttlc_onset_round)
  
  
 # scale_color_gradient(low = "firebrick3", high = "rosybrown1") + guides(color = FALSE) +
  
  #add custom legend 
  #geom_segment(aes(x = 15, xend = 15.5, y = -1, yend = -1), col = "rosybrown1", size = 1.5) +
  #geom_segment(aes(x = 15, xend = 15.5, y = -1.75, yend = -1.75), col = "firebrick3", size = 1.5) +
  #annotate("text", x = 15.75, y = 0, label = expression("TTLC"["End of Trial"]), size = 3) +
  #annotate("text", x = 16.25, y = -1, label = "Late onset", size = 2.5) +
  #annotate("text", x = 16.25, y = -1.75, label = "Early onset", size = 2.5) 

#ggplot(filter(data_RTs_cens, cogload == "noload")) +
#  geom_point(aes(x = ttlc_onset, y= ttlc_takeover), alpha = .25, col = data_col) + #raw data
#  geom_point(aes(x = ttlc_onset, y= ttlc_end_of_trial, col = factor(onsettime)), alpha = .25) + #raw data
#  facet_wrap(~ttlc_onset)
 


print(ribbon)
ggsave("overall_predictiveintervals_ttlc_load_log_nointer.png", plot = ribbon, dev = "png", width = 18, height = 8.5, units = "cm", dpi = 300, type = "cairo")
  



```


```{r, calculate how many are above 99% bounds}

ttlc_df <- data_RTs_cens %>% 
  ungroup() %>% 
  select(ttlc_onset) %>% 
  unique()

cogload <- c("noload")
#ppid <- c(1:12,14:20)
ttlc_onset <- as.vector(ttlc_df$ttlc_onset)
pred_list <- expand_grid(ttlc_onset, cogload)
preds <- predict(MOD, newdata=pred_list, summary=TRUE, allow_new_levels = TRUE, probs = c(.995)) %>% 
  cbind(pred_list) %>% 
  group_by(ttlc_onset) %>% 
  mutate(Estimate = mean(Estimate),
         Q99.5 = max(Q99.5))

total_trials <- nrow(data_RTs_cens)

preds_combined <- left_join(data_RTs_cens, preds, by = c("ttlc_onset","cogload"))
exceed <- filter(preds_combined, ttlc_takeover > Q99.5)

print(nrow(exceed)/total_trials)


```


```{r, Fig 2 - predictive intervals for cogload conditions}
MOD<-m9.gauss
#parnames(m9.gauss)

onesd = .683
onesd.l = .5 - (onesd/2)
onesd.u = .5 + (onesd/2)
twosd = .955
twosd.l = .5 - (twosd/2)
twosd.u = .5 + (twosd/2)


ttlc_onset <- seq(1, to = 17, by = .5)
#mean_censoring <- ttlc_onset - (15 - avg_onset)
#censor <- data.frame(ttlc_onset, mean_censoring)
#ppid <- 1:20
cogload <- c("noload","load")
pred_list <- expand_grid(ttlc_onset, cogload)
preds <- predict(MOD, newdata=pred_list, summary=TRUE, allow_new_levels = TRUE, probs = c(twosd.l, onesd.l, onesd.u, twosd.u)) %>% 
  cbind(pred_list) %>%
  group_by(ttlc_onset, cogload) %>% 
  mutate(Estimate = mean(Estimate),
         Q2.25 = min(Q2.25),
         Q15.85 = min(Q15.85),
         Q84.15 = min(Q84.15),
         Q97.75 = max(Q97.75))



#preds_sig <- fitted(MOD, newdata=pred_list, summary=TRUE, re_formula = NULL, allow_new_levels = TRUE, probs = c(twosd.l, onesd.l, onesd.u, twosd.u), dpar = "sigma") %>% 
#  cbind(pred_list)

#names(preds_sig)[1] <- "sigma"
#fixedeffs <- full_join(preds, preds_sig, by = c("ttlc_onset","cogload"))

#old_preds <- preds
cogload_cols = c("#e3372b","#2bd7e3")

ribbon <- ggplot(preds, aes(x = ttlc_onset)) +
  geom_ribbon(aes(ymin = Q2.25, ymax = Q97.75, fill = cogload), col = NA, alpha = .1) + #99% band
  geom_ribbon(aes(ymin = Q15.85, ymax = Q84.15, fill = cogload), col = NA, alpha = .3) + #50% band
  
  
  #geom_line(data = fixedeffs, aes(y = Estimate + sigma, col = cogload), alpha = 1, linetype = "dotted") +
  #geom_line(data = fixedeffs, aes(y = Estimate - sigma, col = cogload), alpha = 1, linetype = "dotted") +
  #geom_line(data = fixedeffs, aes(y = Estimate + (sigma*2), col = cogload), alpha = .5, linetype = "dotted") +
  #geom_line(data = fixedeffs, aes(y = Estimate - (sigma*2), col = cogload), alpha = .5, linetype = "dotted") +
  
  #annotate("text", x = 13.1, y = 4.3, label = expression(mu), hjust = 0, vjust = 0, size = 2.5) +
  #annotate("text", x = 12.75, y = 5.65, label = expression(mu*" + "*sigma), hjust = 0, vjust = 0, size = 2.5) +
  #annotate("text", x = 12.6, y = 7.5, label = expression(mu*" + 2"*sigma), hjust = 0, vjust = 0, size = 2.5) +
  
  #geom_line(aes(y = Q99.5, col = cogload), alpha = .4, linetype = 2) +
  #geom_line(aes(y = Q25, col = cogload), alpha = 1, linetype = 2) +
  #geom_line(aes(y = Q75, col = cogload), alpha = 1, linetype = 2) +
  geom_line(aes(y = Estimate, col = cogload), size = 1) + #mean
  scale_color_manual(values = cogload_cols, guide = guide_legend(reverse = TRUE), labels = c('SupAuto+ACMT', 'SupAuto')) + 
  scale_fill_manual(values = cogload_cols) + guides(fill = FALSE) +
  theme_classic() +
  xlab(expression("TTLC"["Failure"]*" (s)")) + ylab(expression("TTLC"["Takeover"]*" (s)")) +
  coord_cartesian(ylim = c(-1,8), xlim = c(0,13)) +
  theme(legend.position = c(0.2, 0.8),
        legend.title = element_blank())
  
#print(ribbon)
#ggsave("overall_predictiveintervals_nodata.png", plot = ribbon, dev = "png", width = 18, height = 8.5, units = "cm", dpi = 300, type = "cairo")


pars = c("b_Intercept", "b_ttlc_onset", "b_cogloadload", "b_ttlc_onset:cogloadload", "b_sigma_Intercept", "b_sigma_logttlc_onset",
               "b_sigma_cogloadload")# "b_sigma_ttlc_onset:cogloadload")


breaks = c(parse(text = TeX('$\\beta_{\\mu I}$')),
           parse(text = TeX('$\\beta_{\\mu TF}$')),
           parse(text = TeX('$\\beta_{\\mu CL}$')), 
           parse(text = TeX('$\\beta_{\\mu TOCL}$')),
           parse(text = TeX('$e^{\\beta_{\\sigma I}}$')), 
           parse(text = TeX('$\\beta_{\\sigma TF}$')),
           parse(text = TeX('$e^{\\beta_{\\sigma CL}}$')))
               

#                            'd'=TeX('$mode(L_{ij})$'),
#                            'ft'=parse(text = TeX('$R_{ij}$')),
#                            'ew'=parse(text = TeX('$Q_{ij}$')),
#xlab(expression(paste(beta, " TTLC"["Failure"]))) +

draws_coef <- MOD %>% 
  posterior_samples(., pars = pars) %>% 
  gather(key = "b", value = "estimate") %>% 
  group_by(b) %>% 
  mode_hdi() %>% 
  mutate(b = fct_relevel(b, "b_Intercept", "b_ttlc_onset", "b_cogloadload", "b_ttlc_onset:cogloadload", "b_sigma_Intercept", "b_sigma_logttlc_onset",               "b_sigma_cogloadload")) %>% 
  arrange(b)

draws_coef[5,2:4] <- exp(draws_coef[5,2:4])
draws_coef[7,2:4] <- exp(draws_coef[7,2:4])


forest <- ggplot() +
  geom_vline(xintercept = 0, linetype= "dashed", col = "grey80") +
  geom_pointintervalh(data = draws_coef,aes(y = reorder(b, desc(b)), x = estimate, xmin = .lower, xmax = .upper), col = "black", fatten_point = .5) +
  theme_classic() +
  scale_y_discrete(labels = rev(breaks))+
  ylab("Coefficients") +
  xlab("Estimate") 


#bottom_row <- plot_grid(forest_mu, forest_sig, ncol =2, labels = c("B","C"), label_size = 12)

effects_grid <- plot_grid(forest, ribbon, ncol = 2, labels = c("A","B"), label_size = 12, rel_widths = c(1,1.5))
print(effects_grid)
ggsave("ttlc_effects_v4.png", plot = effects_grid, dev = "png", width = 18, height = 7, units = "cm", dpi = 300, type = "cairo")

#ggsave("fixed_effects_ttlctakeover.png", plot = effects_grid, dev = "png", width = 18, height = 7, units = "cm", #dpi = 300, type = "cairo")
```

```{r, scratchpad}


```


```{r, functions for predicting random effect distributions, minus estimation uncertainty}

#predictive distribution of map and sigma for single row of parameters (so you can choose to include uncertainty or not)
predict_condition_dpars_fixed <- function(row, ttlc_onset){
  
  
  
  
  #########
  # in the model mu and sigma are predicted independently in seperate regression models.
  # by construction all the coefficients in each model have estimated sds and correlations with one another
  # here we formulate a covariance matrix then simulate a predictive distribution of coefficients for both mu and sigma.
  
  # mu = b_Intercept + b_ttlc_onset*ttlc_onset + b_cogloadload * cogload + b_ttlc_onset:cogloadload * ttlc_onset*cogload
  
  #log(sigma) = b_sigma_Intercept + b_sigma_logttlc_onset*log(ttlc_onset) + b_sigma_cogloadload*cogload
  #########
  row <- select(row, starts_with('b'))
  mu_dist <- row
  sig_dist <- row
  
    for (to in ttlc_onset){
      varname <- paste(to, "load", sep="_")
    
    mu_dist[[varname]] <- with(row, b_Intercept + b_ttlc_onset*to + b_cogloadload*1 + `b_ttlc_onset.cogloadload`*(to*1))
    sig_dist[[varname]] <- with(row, b_sigma_Intercept + b_sigma_logttlc_onset*log(to) + b_sigma_cogloadload*1)
    
    
    varname <- paste(to, "noload", sep="_")
    mu_dist[[varname]] <- with(row, b_Intercept + b_ttlc_onset*to + b_cogloadload*0 + `b_ttlc_onset.cogloadload`*(to*0))
    sig_dist[[varname]] <- with(row, b_sigma_Intercept + b_sigma_logttlc_onset*log(to) + b_sigma_cogloadload*0)
  }
      
      
  mu_long <- mu_dist %>% 
    pivot_longer(-starts_with('b'),
                 names_to = c("ttlc_onset","cogload"),
                 names_sep = "_",
                 values_to = "mu")
  
  sig_long <- sig_dist %>% 
    pivot_longer(-starts_with('b'),
                 names_to = c("ttlc_onset","cogload"),
                 names_sep = "_",
                 values_to = "sigma")
  
  #exponentiate sigma so you can treat it as a distributional parameters henceforth
  sig_long$sigma <- exp(sig_long$sigma)

  #return here
  dpar_dists <- list(mu_long, sig_long)
  return(dpar_dists)
  
  
}


predict_coeff_dist <- function(row, nsamples){

  #########
  # in the model mu and sigma are predicted independently in seperate regression models.
  # by construction all the coefficients in each model have estimated sds and correlations with one another
  # here we formulate a covariance matrix then simulate a predictive distribution of coefficients for both mu and sigma.
  
  # mu = b_Intercept + b_ttlc_onset*ttlc_onset + b_cogloadload * cogload + b_ttlc_onset:cogloadload * ttlc_onset*cogload
  
  #log(sigma) = b_sigma_Intercept + b_sigma_logttlc_onset*log(ttlc_onset) + b_sigma_cogloadload*cogload
  #########
  

  
  #### mu #####
  #intercept
  cov_int_to <- with(row, sd_ppid__Intercept*sd_ppid__ttlc_onset*cor_ppid__Intercept__ttlc_onset)
  cov_int_cl <- with(row, sd_ppid__Intercept*sd_ppid__cogloadload*cor_ppid__Intercept__cogloadload)
  cov_int_to.cl <- with(row, sd_ppid__Intercept*sd_ppid__ttlc_onset.cogloadload*cor_ppid__Intercept__ttlc_onset.cogloadload)
  
  #ttlc
  cov_to_cl <- with(row,sd_ppid__ttlc_onset*sd_ppid__cogloadload*cor_ppid__ttlc_onset__cogloadload)
  cov_to_to.cl <- with(row,sd_ppid__ttlc_onset*sd_ppid__ttlc_onset.cogloadload*cor_ppid__ttlc_onset__ttlc_onset.cogloadload)
  
  #cl
  cov_cl_to.cl <- with(row, sd_ppid__cogloadload*sd_ppid__ttlc_onset.cogloadload*cor_ppid__cogloadload__ttlc_onset.cogloadload)
  
  
  cov_mat_mu = with(row, matrix(
    c(sd_ppid__Intercept^2, cov_int_to, cov_int_cl, cov_int_to.cl,
      cov_int_to, sd_ppid__ttlc_onset^2, cov_to_cl, cov_to_to.cl,
      cov_int_cl, cov_to_cl, sd_ppid__cogloadload^2, cov_cl_to.cl,
      cov_int_to.cl, cov_to_to.cl, cov_cl_to.cl, sd_ppid__ttlc_onset.cogloadload^2), ncol = 4))
  
  
  print(cov_mat_mu)
  mu_dist <- as.data.frame(MASS::mvrnorm(nsamples, c(row$b_Intercept, row$b_ttlc_onset, row$b_cogloadload, row$b_ttlc_onset.cogloadload), cov_mat_mu))
  
  colnames(mu_dist) <- c("b_Intercept","b_ttlc_onset","b_cogloadload","b_ttlc_onset.cogloadload")
  mu_dist$pp <- 1:nsamples
  
  #### sigma ####
  
  #intercept
  cov_int_to <- with(row, sd_ppid__sigma_Intercept*sd_ppid__sigma_logttlc_onset*cor_ppid__sigma_Intercept__sigma_logttlc_onset)
  cov_int_cl <- with(row, sd_ppid__sigma_Intercept*sd_ppid__sigma_cogloadload*cor_ppid__sigma_Intercept__sigma_cogloadload)
  cov_to_cl <- with(row,sd_ppid__sigma_logttlc_onset*sd_ppid__sigma_cogloadload*cor_ppid__sigma_logttlc_onset__sigma_cogloadload)
  
  cov_mat_sig = with(row, matrix(
    c(sd_ppid__sigma_Intercept^2, cov_int_to, cov_int_cl, 
      cov_int_to, sd_ppid__sigma_logttlc_onset^2, cov_to_cl, 
      cov_int_cl, cov_to_cl, sd_ppid__sigma_cogloadload^2), ncol = 3))
  
  
  sig_dist <- as.data.frame(MASS::mvrnorm(nsamples, c(row$b_sigma_Intercept, row$b_sigma_logttlc_onset, row$b_sigma_cogloadload), cov_mat_sig))
  
  colnames(sig_dist) <- c("b_sigma_Intercept","b_sigma_logttlc_onset","b_sigma_cogloadload")
  sig_dist$pp <- 1:nsamples
  
  #return for two distributions here here.
  dists <- list(mu_dist, sig_dist)
  return(dists)
}
  
  
predict_condition_dpars <- function(ttlc_onset, coef_dists){   
  
  mu_dist <- coef_dists[[1]]
  sig_dist <- coef_dists[[2]]
  
  for (to in ttlc_onset){
    varname <- paste(to, "load", sep="_")
    
    mu_dist[[varname]] <- with(mu_dist, b_Intercept + b_ttlc_onset*to + b_cogloadload*1 + `b_ttlc_onset.cogloadload`*(to*1))
    sig_dist[[varname]] <- with(sig_dist, b_sigma_Intercept + b_sigma_logttlc_onset*log(to) + b_sigma_cogloadload*1)
    
    
    varname <- paste(to, "noload", sep="_")
    mu_dist[[varname]] <- with(mu_dist, b_Intercept + b_ttlc_onset*to + b_cogloadload*0 + `b_ttlc_onset.cogloadload`*(to*0))
    sig_dist[[varname]] <- with(sig_dist, b_sigma_Intercept + b_sigma_logttlc_onset*log(to) + b_sigma_cogloadload*0)
  }
      
      
  mu_long <- mu_dist %>% 
    pivot_longer(-c(starts_with('b'),'pp'),
                 names_to = c("ttlc_onset","cogload"),
                 names_sep = "_",
                 values_to = "mu")
  
  sig_long <- sig_dist %>% 
    pivot_longer(-c(starts_with('b'),'pp'),
                 names_to = c("ttlc_onset","cogload"),
                 names_sep = "_",
                 values_to = "sigma")
  
  #exponentiate sigma so you can treat it as a distributional parameters henceforth
  sig_long$sigma <- exp(sig_long$sigma)

  #return here
  dpar_dists <- list(mu_long, sig_long)
  return(dpar_dists)
}
  

simulate_ttlctakeovers <- function(dpar_dists, nobs = 10){
  #simulate participants. since mu and sigma are considered independent in the model, just randomly draw from them separately
  mu_long <- dpar_dists[[1]]
  sig_long <- dpar_dists[[2]]
  mu_long$sigma <- sig_long$sigma
  
  #for each participant you want to sample n obs at the conditions.
  obs <- rnorm(nrow(mu_long)*nobs, mu_long$mu, mu_long$sigma)
  full_df <- cbind(mu_long, matrix(obs, nrow = nrow(mu_long), byrow = FALSE))
  full_df$ttlc_onset <- as.numeric(full_df$ttlc_onset)
  return(full_df)
}


quantile_range <- function(full_df, quantiles){
  
  df <- full_df %>% 
    pivot_longer(matches("^[[:digit:]]+"),
                 values_to = "ttlc_takeover") %>% 
    filter(ttlc_takeover < ttlc_onset) %>% #truncated dist
    group_by(ttlc_onset, cogload) %>% 
    summarise(q1 = quantile(ttlc_takeover, quantiles[1]),
              q2 = quantile(ttlc_takeover, quantiles[2]),
              range95 = q2 - q1)
  
  return(df)
}
  
  
  
  
avg_pcross <- function(dpar_dists){
  
  #for each participant (randomly drawn mu and sigma) calculate a pcross.
  mu_long <- dpar_dists[[1]]
  sig_long <- dpar_dists[[2]]
  
  mu_long$sigma <- sig_long$sigma
  mu_long <- mu_long %>% 
    group_by(pp, ttlc_onset, cogload) %>% 
    mutate(pcross = pnorm(0, mu, sigma))
  
  
  pcross_avg <- mu_long %>% 
    ungroup() %>% 
    group_by(ttlc_onset, cogload) %>% 
    summarise(pcross = mean(pcross, na.rm = TRUE))
  pcross_avg$ttlc_onset <- as.double(pcross_avg$ttlc_onset)
  
  return(pcross_avg)
}




```


```{r, obtaining MAP point estimate by maximising over joint posterior}

#use map estimate from bayestestR
#doesn't give sds, but could get that from the SDS of the modes. Not quite this doesn't seem to be how it works.

#sample_new_levels = gaussian does what I do manually (i.e. take each row and sample using the covar matrix).
#but how to do this using the MAP jointly credible?

#https://github.com/paul-buerkner/brms/issues/191 useful discussion on the sample new levels value.

#but MAP_estimate doesn't a jointly credible sample space.bayes

#have posted on stan forums for the MAP params. If they don't get back to me I'll not worry about partialling out the estimation uncertainty.

#https://mc-stan.org/rstan/reference/stanmodel-method-optimizing.html

#https://easystats.github.io/bayestestR/reference/map_estimate.html

pars <- parnames(MOD)
map_btest <- map_estimate(MOD,effects = "all")

map_sig <- fitted(MOD, newdata=pred_list, summary=TRUE, re_formula = NA, dpar = "sigma")# %>% 
map_sig_pred <- fitted(MOD, newdata=pred_list, summary=FALSE, re_formula = NULL, allow_new_levels = T, sample_new_levels = "gaussian", dpar = "sigma")# %>% 

describe_posterior(
  MOD,
  effects = "all",
  component = "all",
  centrality = "all"
)
  #cbind(pred_list) %>% 
  #mutate(range95 = Estimate*2)


#is the sd of a sample row just the sd of the estimated fixed effects? 
samples <- as.data.frame(MOD[["fit"]]@sim[["samples"]][[1]])
samples <- samples[1001:10000, ]


string = "r_ppid.1.Intercept."
pattern = "r.ppid.\\d{1,}.Intercept."
grep(pattern, string)
samplerow <- samples[1,]
cols = grep(pattern, names(samplerow))
print(cols)
grp_ints <- samplerow[cols]
sd_ints <- sd(grp_ints)
samplerow$sd_ppid__Intercept

sm <- MOD[["fit"]]@stanmodel
class(sm)
map_rstan <- optimizing(sm)


post <- posterior_samples(MOD)
samples <- as.data.frame(MOD[["fit"]]@sim[["samples"]][[1]])
samples <- samples[1001:10000, ]
#to get the full random effects parameters you need to do it yourself
mymap <- sapply(samples, map_estimate)
mymaps <- data.frame("parameters" = names(mymap), "MAP" = mymap)
map_params <- mymaps %>% 
  pivot_wider(names_from = "parameters",
              values_from = "MAP")

#the map_param covariance is not positive definite.
#instead, let's choose one closest to the modal likehood.
logsumexp <- function (x) {
  y = max(x)
  y + log(sum(exp(x - y)))
}

softmax <- function (x) {
  exp(x - logsumexp(x))
}

library(mda)

lp <- log_posterior(MOD)

plot(lp$Value)
hist(softmax(lp$Value))
hist(lp$lik, binsize = .1)
plot(lp$lik)

ggplot(lp, aes(x = lik)) + geom_histogram(binwidth = .01)

lp$lp <- samples$lp__
lp <- lp %>% 
  mutate(lik = softmax(Value))
ll <- log_lik(MOD)
highest_lp <- samples[719,]

ll_manual <- rowSums(ll)
idx <- which.max(ll_manual)
ll_exp <- exp(ll_manual - max(ll_manual))
plot((ll_exp))
hist(ll_exp, breaks = 30)

ll_exp_df <- as.data.frame(ll_exp)
ggplot(filter(ll_exp_df, ll_exp < .001), aes(x = ll_exp)) + geom_histogram(binwidth = .0001)

highest_manual_ll <- samples[3212,]

hist(samples$lp__)
modelp <- Mode(samples$lp__)
diff <- modelp -samples$lp__
idx <- which.min(abs(diff))

pars <- parnames(MOD)[1:23]

mymap <- sapply(samples, map_estimate)
mymaps <- data.frame("parameters" = names(mymap), "MAP" = mymap)
map_params1 <- samples[idx, ]


optimizing(MOD)

sm <- MOD[['fit']]@stanmodel
rstan::optimizing(sm)

```


```{r, random effects plots}
twosd = .955
twosd.l = .5 - (twosd/2)
twosd.u = .5 + (twosd/2)


ttlc_onset <- seq(.25, to = 15, by = .25)
#mean_censoring <- ttlc_onset - (15 - avg_onset)
#censor <- data.frame(ttlc_onset, mean_censoring)
#ppid <- 1:20
cogload <- c("noload","load")

pred_list <- expand_grid(ttlc_onset, cogload)

#MAP range (FIXED EFFECTS)
map_sig <- fitted(MOD, newdata=pred_list, summary=TRUE, re_formula = NA, dpar = "sigma") %>% 
  cbind(pred_list) %>% 
  mutate(range95 = Estimate*4)

#MAP + Fixed effect MODEL ERROR 
pop_range <- predict(MOD, newdata=pred_list, summary=TRUE, re_formula = NA, probs = c(twosd.l, twosd.u)) %>% 
  cbind(pred_list) %>% 
  mutate(range95 = Q97.75 - Q2.25)



#MAP range for MAP FIXED + RANDOM

samples <- as.data.frame(MOD[["fit"]]@sim[["samples"]][[1]])
samples <- samples[1001:10000, ]
parmeds <- sapply(samples, median)
mymeds <- data.frame("parameters" = names(parmeds), "med" = parmeds)
med_params <- mymeds %>% 
  pivot_wider(names_from = "parameters",
              values_from = "med")

coef_dists <- predict_coeff_dist(med_params, 500) #coefficients.
condition_dpars <- predict_condition_dpars(ttlc_onset, coef_dists) #dpars predicted from regmodel
obs <- simulate_ttlctakeovers(condition_dpars, nobs = 50)
raneff_range <- quantile_range(obs, c(twosd.l, twosd.u))


dpars_fixed <- predict_condition_dpars_fixed(med_params, ttlc_onset)
sig_fixed <- dpars_fixed[[2]] %>% 
  mutate(range95 = sigma*4)
sig_fixed$ttlc_onset <- as.numeric(sig_fixed$ttlc_onset)
obs_fixed <- simulate_ttlctakeovers(dpars_fixed, nobs = 10000)
fixeff_range <- quantile_range(obs_fixed, c(twosd.l, twosd.u))
fixeff_range$ttlc_onset <- as.numeric(fixeff_range$ttlc_onset)


print(quantile(rnorm(10000), twosd.l))


#FULL PREDICTIVE (FIXED + RANDOM + UNCERTAINTY) 
ppid <- seq(50,100)
pred_list_new <- expand_grid(ttlc_onset, cogload, ppid)

pp_range <- predict(MOD, newdata=pred_list_new, summary=FALSE, allow_new_levels = TRUE, probs = c(twosd.l, twosd.u), sample_new_levels = "gaussian", nsamples = 9000) %>% 
  t() %>% 
  cbind(pred_list_new) 
  #mutate(range95 = Q97.75 - Q2.25)

pp_quantiles <- pp_range %>% 
   pivot_longer(matches("^[[:digit:]]+"),
                 values_to = "ttlc_takeover") %>% 
    group_by(ttlc_onset, cogload) %>% 
    summarise(q1 = quantile(ttlc_takeover, twosd.l, na.rm = TRUE),
              q2 = quantile(ttlc_takeover, twosd.u, na.rm = TRUE),
              range95 = q2 - q1)

print(mean(sig_fixed$range95 / pp_quantiles$range95))
print(mean(raneff_range$range95 / pp_quantiles$range95))
print(1- mean(raneff_range$range95 / pp_quantiles$range95))
print(mean(raneff_range$range95 / pp_quantiles$range95) - mean(sig_fixed$range95 / pp_quantiles$range95))


range_plot <- ggplot(pop_range, aes(x = ttlc_onset, y = range95, fill = cogload, col = cogload)) +
  
  geom_area(data = pop_range, alpha = .1) + #99%band
  #geom_ribbon(data = pp_range, aes(ymin = 0, ymax = range95, fill = cogload, col = cogload), alpha = .1) + #50%
  geom_area(data = pp_quantiles, alpha = .1) + #50%band
  geom_area(data = sig_fixed, alpha = .1) + #50% band
  geom_area(data = raneff_range, alpha = .1) +
  
  #geom_line(data = fixeff_range, aes(y = range95), col = "black") +
  #geom_line(data = sig_fixed, aes(y = range95), col = "green") +
  

  #geom_ribbon(data = raneff_range_meds, aes(ymin = 0, ymax = range95, fill = cogload), col = "black", alpha = .1) +#50% band
  #scale_color_manual(values = cogload_cols, guide = guide_legend(reverse = TRUE), labels = c('SupAuto+ACMT', 'SupAuto')) + 
  #scale_fill_manual(values = cogload_cols) + guides(fill = FALSE) +
  theme_classic() +
  xlab(expression("TTLC"["Failure"]*" (s)")) + ylab(expression("95.5% Range (Two Sigma)"))+
  facet_wrap(~cogload) +
  coord_cartesian(xlim = c(0,13), ylim = c(0, 10)) +
  ylab(parse(text = TeX('$\\pm 2\\sigma$'))) +
    #round facet titles and place legend position
  theme(panel.border = element_blank(), 
       panel.background = element_blank(), 
       panel.grid = element_blank(),
       strip.background = element_blank(),
       legend.position = c(0.3, 0.9),
       legend.background = element_blank(),
       legend.title = element_blank(),
       legend.direction = ("horizontal")) 
  
  #coord_cartesian(ylim = c(-1,8), xlim = c(0,13)) 
  #theme(legend.position = c(0.2, 0.8),
   #     legend.title = element_blank())


print(range_plot)

ggsave("variability_stack.png", plot = range_plot, dev = "png", width = 18, height = 7, units = "cm", dpi = 300, type = "cairo")
ggsave("variability_stack.svg", plot = range_plot, dev = "svg", width = 18, height = 7, units = "cm", dpi = 300)

```




```{r, Fig 3 - histogram of balanced condition and model density}

balanced_ttlc_onset <- data_RTs_cens %>% 
  ungroup() %>% 
  filter(design == "balanced") %>% 
  select(ttlc_onset) %>% 
  unique()

cogload <- c("noload","load")
#ppid <- c(1:12,14:20)
ttlc_onset <- as.vector(balanced_ttlc_onset$ttlc_onset)
pred_list <- expand_grid(ttlc_onset, cogload)
preds <- pred_list %>% 
  add_predicted_draws(MOD, allow_new_levels = TRUE, sample_new_levels = "gaussian")
  
p_hist <- ggplot(filter(data_RTs_cens, design == "balanced", premature == 0, disengaged == 1), aes(x = ttlc_takeover, y = ..density.., group = cogload, fill = cogload)) +
  #add raw data
  geom_histogram(alpha = .4, position = "identity", bins = 40) +
  
  #add model predictive density
  stat_density(geom="line", position="identity", data=preds, aes(x = .prediction, col = cogload), trim = TRUE, size = .8, n =2^8) +
  
  #add vline for ttlc_onset
  geom_vline(aes(xintercept = ttlc_onset), col = "grey40", linetype =2) +
  
  #add vline for ttlc_end_of_trial
 # geom_vline(aes(xintercept = ttlc_end_of_trial), col = "grey80", linetype =3) +
  
  xlab(expression("TTLC"["Takeover"]*" (s)")) + theme_classic() + 
  facet_wrap(~ttlc_onset, scales = "free", labeller = as_labeller(function(x)paste0((round(as.double(x),2)), " s"))) +
  theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) +
  scale_color_manual(values = cogload_cols) + scale_fill_manual(values = rev(cogload_cols)) + guides(fill = FALSE) +
  xlim(-.5,NA) +
  
  #round facet titles and place legend position
  theme(panel.border = element_blank(), 
       panel.background = element_blank(), 
       panel.grid = element_blank(),
       strip.background = element_blank(),
       axis.line.y=element_blank(),
       legend.position = c(0.55, 0.9),
       legend.background = element_blank()) 
  
  
  
print(p_hist)

#this plot is a bit messy and I don't think it should be included.
ggsave("histogram_ttlc_loads.png", plot = p_hist, dev = "png", width = 18, height = 10, units = "cm", dpi = 300, type = "cairo")


```



```{r, oldFig3 estimation of fixed effect on mean ttlc_takeover}


ttlc_onset <- seq(1, to = 13, by = .1)
cogload <- c("noload","load")
pred_list <- expand_grid(ttlc_onset, cogload)
preds <- fitted(MOD, newdata=pred_list, summary=TRUE, re_formula = NA, probs = c(.005, 0.025, .25, .75, 0.975, .995), resp = "ttlc_takeover") %>% 
  cbind(pred_list) 

cols = c("#16bf81", "#c21756")
mn_ribbon <- ggplot(preds, aes(x = ttlc_onset, group = cogload, col = cogload)) +
 # geom_line(aes(y = exp(Q0.5)), alpha = .2, linetype = 2) +
#    geom_line(aes(y = exp(Q99.5)), alpha = .2, linetype = 2) +
    geom_line(aes(y = Q2.5), alpha = .5, linetype = 2) +
    geom_line(aes(y = Q97.5), alpha = .5, linetype = 2) +
#    geom_line(aes(y = exp(Q25)), alpha = .75, linetype = 2) +
#    geom_line(aes(y = exp(Q75)), alpha = .75, linetype = 2) +
    scale_colour_manual(values = cols) +
    geom_line(aes(y = Estimate)) +
  theme_classic() +
  xlab("ttlc onset (s)") + ylab("ttlc takeover (s)") + ylim(0,6) +
  theme(legend.position = c(0.2, 0.8))

print(mn_ribbon)


#ln(RT) = N ( mu, sigma)
#mu = log(b1 + b2 + b3)
#RT med = exp(mu) #median of RT distribution
#RT med= b1 + b2 + b3
#the coefficients are in seconds units, and they can be interpreted as a direct effect on the median of the distribution

#plot distribution of main effects and interactions.
#get_variables(MOD)

#fixef_raw <- as.data.frame(fixef(MOD, summary = FALSE))
#fixef_hdi <- as.data.frame(fixef(MOD, summary = TRUE, probs = c(0.025, 0.975)))

#head(fixef_raw)
#print(fixef_hdi)

remove_yticks <-  theme(axis.text.y = element_blank(),
  axis.ticks.y = element_blank())


#ttlc
b = "b_ttlc_onset"
ps = posterior_samples(MOD, pars = b)
ps_hdi <- mode_hdi(ps[[b]], .width = .95) 
ttlcfixplot <- ggplot() +
  geom_histogram(data = ps, aes_string(x = b), bins = 60, fill = "skyblue3", alpha = 1)+
  geom_segment(data=ps_hdi, aes(x=ymin, y=0, xend=ymax, yend=0), size=1) + 
  geom_point(data=ps_hdi, aes(x=y, y=0), size=2) +
  theme_classic() + 
  geom_vline(xintercept=0, linetype="dashed", col = "grey40") +
  xlim(0, .5) + xlab("ttlc takeover increase with ttlc onset (s)") + ylab("") + remove_yticks

print(ttlcfixplot)

#cogload
b = "b_cogloadload"
ps = posterior_samples(MOD, pars = b)
ps_hdi <- mode_hdi(ps[[b]], .width = .95) 
clfixplot <- ggplot() + 
  geom_histogram(data = ps, aes_string(x = b), bins = 60, fill = "seagreen4", alpha = 1)+
  geom_segment(data=ps_hdi, aes(x=ymin, y=0, xend=ymax, yend=0), size=1) + 
  geom_point(data=ps_hdi, aes(x=y, y=0), size=2) +
  theme_classic() + 
  geom_vline(xintercept=0, linetype="dashed", col = "grey40") + 
  xlim(-.4, .1) + xlab("ttlc takeover increase when loaded (s)") + ylab("") + remove_yticks
  
print(clfixplot)

  
#cogload * ttlc
b = "b_ttlc_onset:cogloadload"
ps = posterior_samples(MOD, pars = b)
ps_hdi <- mode_hdi(ps[[b]], .width = .95) 
interplot <- ggplot() +
  geom_histogram(data = ps, aes(x = .data[[b]]), bins = 60, fill = "turquoise4", alpha = 1)+
  geom_segment(data=ps_hdi, aes(x=ymin, y=0, xend=ymax, yend=0), size=1) + 
  geom_point(data=ps_hdi, aes(x=y, y=0), size=2) +
  theme_classic() +
  geom_vline(xintercept=0, linetype="dashed", col = "grey40") +
  xlim(-.25, .25) + xlab("Change in TTLC slope with load (s)") + ylab("") +remove_yticks

print(interplot)


b = "cor_ppid__ttlc_onset__cogloadload"
cor = posterior_samples(MOD, pars = b)
cor_hdi <- mode_hdi(cor[[b]], .width = .95) 

corplot <- ggplot() +
  geom_histogram(data = cor, aes_string(x = b), bins = 60, fill = "turquoise4", alpha = 1)+
  geom_segment(data=cor_hdi, aes(x=ymin, y=0, xend=ymax, yend=0), size=1) + 
  geom_point(data=cor_hdi, aes(x=y, y=0), size=2) +
  theme_classic() +
  geom_vline(xintercept=0, linetype="dashed", col = "grey40") +
  xlab("Correlation between slope and load") + ylab("") +remove_yticks

print(corplot)


right_col <- plot_grid(ttlcfixplot, clfixplot, corplot, nrow = 3, labels = c("B","C","D"), label_size = 12)
full_grid <- plot_grid(mn_ribbon, right_col, ncol = 2, labels = c("A",""), label_size = 12, rel_widths = c(1,.75))
print(full_grid)

ggsave("population_coefficient_means_ttlc.png", plot = full_grid, dev = "png", width = 18, height = , units = "cm", dpi = 300, type = "cairo")

```


```{r, save as above but the predicted observations for an unseen participant}


ttlc_onset <- seq(1, to = 13, by = .1)
cogload <- c("noload","load")
ppid <- 50
pred_list <- expand_grid(ttlc_onset, cogload, ppid)
preds <- predict(MOD, newdata=pred_list, summary=TRUE, allow_new_levels = TRUE, probs = c(.005, 0.025, .25, .75, 0.975, .995), resp = "ttlc_takeover") %>% 
  cbind(pred_list) 

cols = c("#16bf81", "#c21756")
mn_ribbon <- ggplot(preds, aes(x = ttlc_onset, group = cogload, col = cogload)) +
 # geom_line(aes(y = exp(Q0.5)), alpha = .2, linetype = 2) +
#    geom_line(aes(y = exp(Q99.5)), alpha = .2, linetype = 2) +
    geom_line(aes(y = Q2.5), alpha = .5, linetype = 2) +
    geom_line(aes(y = Q97.5), alpha = .5, linetype = 2) +
#    geom_line(aes(y = exp(Q25)), alpha = .75, linetype = 2) +
#    geom_line(aes(y = exp(Q75)), alpha = .75, linetype = 2) +
    scale_colour_manual(values = cols) +
    geom_line(aes(y = Estimate)) +
  theme_classic() +
  xlab("ttlc onset (s)") + ylab("ttlc takeover (s)") + #ylim(0,6) +
  theme(legend.position = c(0.2, 0.8))

print(mn_ribbon)
#there's a bug here with the predicted regression line for a new participant at really low ttlc values

#plot distribution of main effects and interactions.

#get distribution for unseen participant.
#sample from distribution.

#with a little help from Kurtz: https://bookdown.org/ajkurz/Statistical_Rethinking_recoded/multilevel-models.html

post <- posterior_samples(MOD)


mn = "b_ttlc_onset"
sd = "sd_ppid__ttlc_onset"
new_obs <- rnorm(n= nrow(post), mean = post[[mn]], sd   = post[[sd]])
new_obs_hdi <- mode_hdi(new_obs, width = .95)

#ttlc
ttlcfixplot <- ggplot() +
  geom_histogram(data = data.frame(new_obs), aes_string(x = new_obs), bins = 60, fill = "skyblue3", alpha = 1)+
  geom_segment(data=new_obs_hdi, aes(x=ymin, y=0, xend=ymax, yend=0), size=1) + 
  geom_point(data=new_obs_hdi, aes(x=y, y=0), size=2) +
  theme_classic() + 
  geom_vline(xintercept=0, linetype="dashed", col = "grey40") +
xlab("ttlc slope of unseen participants (s)") + ylab("") + remove_yticks

print(ttlcfixplot)

#cogload

mn = "b_cogloadload"
sd = "sd_ppid__cogloadload"
new_obs <- rnorm(n= nrow(post), mean = post[[mn]], sd   = post[[sd]])
new_obs_hdi <- mode_hdi(new_obs, width = .95)

clfixplot <- ggplot() +
  geom_histogram(data = data.frame(new_obs), aes_string(x = new_obs), bins = 60, fill = "seagreen4", alpha = 1)+
  v
  geom_point(data=new_obs_hdi, aes(x=y, y=0), size=2) +
  theme_classic() + 
  geom_vline(xintercept=0, linetype="dashed", col = "grey40") +
  xlab("cogload effect of unseen participants (s)") + ylab("") + remove_yticks
  
print(clfixplot)


#participant variability 
  
#cogload * ttlc

varplot <- ggplot(data = post) +
  geom_histogram(aes(x = sd_ppid__ttlc_onset), bins = 60, fill = "skyblue3", alpha = .5)+
  geom_histogram(aes(x = sd_ppid__cogloadload), bins = 60, fill = "seagreen4", alpha = .5)+
  theme_classic() +
  xlab("between participant variability") + ylab("") +remove_yticks

print(varplot)



right_col <- plot_grid(ttlcfixplot, clfixplot, varplot, nrow = 3, labels = c("B","C","D"), label_size = 12)
full_grid <- plot_grid(mn_ribbon, right_col, ncol = 2, labels = c("A",""), label_size = 12, rel_widths = c(1,.75))
print(full_grid)

ggsave("population_coefficient_newparticipants_ttlc.png", plot = full_grid, dev = "png", width = 18, height = 10, units = "cm", dpi = 300, type = "cairo")

```

```{r, simulated and posterior mean distribution}
load('m9.gauss.rda')
MOD <- m9.gauss


#predictive distribution of new params using cov matrix. But this doesn't take into account the uncertainty in the covariance? 
#to do that I need to construct the cov matrix for each posterior sample then simulate? Correct? 

#I think this is a simulated mean distribution.
n = 9000 #to mathc samples
b = c("b_ttlc_onset","b_cogloadload")
ps = posterior_samples(MOD, pars = b)

full_vcov <- vcov(MOD)

b_p = c("ttlc_onset","cogloadload")
vcovar <- as.matrix(vcov(MOD, pars = b_p))

means = c(mean(ps[[b[1]]]), mean(ps[[b[2]]]))
dist <- MASS::mvrnorm(n, means, vcovar)

#for (col in b){print(mode_hdi(ps[[col]], .width = .95))}

regplot <- ggplot() +
  geom_point(data=ps, aes_string(x=b[1], y=b[2]), alpha = .1) +
  geom_point(data=as.data.frame(dist), aes_string(x=b_p[1], y=b_p[2]), alpha = .1, col = "blue") +
  theme_classic() + 
  geom_vline(xintercept=0, linetype="dashed", col = "grey40") +
  geom_hline(yintercept=0, linetype="dashed", col = "grey40") 
  #xlim(0, .5) + xlab("ttlc takeover increase with ttlc onset (s)") + ylab("") + remove_yticks

print(regplot)



```

```{r, Fig4 simulated and predicted mean distribution}
#load('m9.gauss.rda')
#MOD <- m9.gauss


#predictive distribution of new params using cov matrix. 
#to take into account estimation uncertainty I need to construct the cov matrix for each posterior sample then simulate.

mvpredict <- function(draw){
  
  #burkner uses rmultinomal to do a vectorised version @ https://github.com/paul-buerkner/brms/blob/master/R/extract_draws.R
  estimate = c(draw$b_ttlc_onset,draw$b_cogloadload)
  sds = c(draw$sd_ppid__ttlc_onset, draw$sd_ppid__cogloadload)
  cor_d = draw$cor_ppid__ttlc_onset__cogloadload
  cov_d = sds[1]*sds[2]*cor_d
  cov_mat = matrix(c(sds[1]^2, cov_d, 
                   cov_d, sds[2]^2), ncol = 2)  
  
  #sample
  est = MASS::mvrnorm(1, estimate, cov_mat)
  return(est)
}

b = c("b_ttlc_onset","b_cogloadload")
b_p = c("ttlc_onset","cogloadload")

post <- posterior_samples(MOD)
mode_hdi(post$cor_ppid__ttlc_onset__cogloadload)

#mode_hdi(post$cor_ppid__sigma_ttlc_onset__sigma_cogloadload)
#hist(post$cor_ppid__sigma_ttlc_onset__sigma_cogloadload)
preds <- post %>% 
  plyr::adply(., .margins = 1, .fun = mvpredict) %>% 
  select(V1, V2) %>% 
  rename(ttlc_onset = V1, cogloadload = V2)
  

#seen participant mean coefficients.
pp_coef <- as.data.frame(coef(MOD)$ppid[, 1, 2:3]) #ttlc and cogload combined coefs estimate

hdis <- lapply(b, function(x) {mean_hdi(post[[x]], .width = .95)}) 

#mean predictive distribution
#MAP predictive distribution
modes <- post %>% 
  select(b_ttlc_onset, b_cogloadload, sd_ppid__ttlc_onset, sd_ppid__cogloadload, cor_ppid__ttlc_onset__cogloadload) %>% 
  sapply(.,Mode)


covar = modes["sd_ppid__ttlc_onset"] * modes["sd_ppid__cogloadload"] * modes["cor_ppid__ttlc_onset__cogloadload"]
cov_mat = matrix(c(modes["sd_ppid__ttlc_onset"]^2, covar, 
                   covar, modes["sd_ppid__cogloadload"]^2), ncol = 2)  

dist <- as.data.frame(MASS::mvrnorm(9000, c(modes["b_ttlc_onset"], modes["b_cogloadload"]), cov_mat))



ylims = c(-.35,.25)
xlims = c(-.05, .55)
margin = .01
xseg = xlims[1]+margin
yseg = ylims[1]+margin

predplot <- ggplot() +
  #geom_point(data=as.data.frame(dist), aes_string(x=b_p[1], y=b_p[2]), alpha = .1, col = "blue") +
  #geom_point(data=preds, aes_string(x=b_p[1], y=b_p[2]), alpha = .3, col = "lightblue") +
  #geom_point(data=dist, aes_string(x=b[1], y=b[2]), alpha = .3, col = "lightblue") +
  #geom_point(data=ps, aes_string(x=b[1], y=b[2]), alpha = .05, col = "dodgerblue3") +

  
  #predicted distribution 95% ellipse excluding uncertainty
  stat_ellipse(data=dist, aes_string(x=b[1], y=b[2]), geom ="polygon", type = "norm",
                 size  = .5, alpha = .8, fill = NA, col = "grey40", linetype = 1,
                 level = .95) +
  
  #predicted distribution 95% ellipse including uncertainty
  stat_ellipse(data=preds, aes_string(x=b_p[1], y=b_p[2]), geom ="polygon", type = "norm",
                 size  = 0, alpha = .8, fill = NA, col = "lightblue", linetype = 2,
                 level = .95) +
  
  #fitted mean 95% ellipse
  stat_ellipse(data=post, aes_string(x=b[1], y=b[2]), geom ="polygon", type = "norm",
                 size  = .5, alpha = .8, fill = NA, col = "black", linetype = 3,
                 level = .95) +
  
  
  #hdis
  #geom_point(data = hdis[[1]], aes(y = yseg, x = y), size = 2, col = "black") + 
  #geom_segment(data = hdis[[1]], aes(y = yseg, x = ymin, yend = yseg, xend = ymax), size = 1, col = "black") +
  #geom_point(data = hdis[[2]], aes(y = y, x = xseg), size = 2, col = "black") + 
  #geom_segment(data = hdis[[2]], aes(y = ymin, x = xseg, yend = ymax, xend = xseg), size = 1, col = "black") +
  
  theme_classic() + 
  geom_vline(xintercept=0, linetype="dashed", col = "grey40") +
  geom_hline(yintercept=0, linetype="dashed", col = "grey40") +
  
  #add participant mean effects
  geom_point(data = pp_coef, aes_string(x=b_p[1], y=b_p[2]), alpha = 1, col = "black") +
  
  coord_fixed(ratio = 1, ylim = ylims, xlim = xlims) +
  
  xlab(expression(paste(beta, " TTLC"["Failure"]))) +
  ylab(expression(paste(beta, " Cogload"))) +
  
  
  #custom legends
  annotate("path", x=.35+.01*cos(seq(0,2*pi,length.out=100)), y=.2+.01*sin(seq(0,2*pi,length.out=100)), hjust =0, vjust = 0, col = "grey40") +
  annotate("text", x=.37, y=.2, label = "MAP 95% Predictive \nDistribution", size = 2.5, hjust =0, vjust = 1) +
  annotate("path", x=.35+.01*cos(seq(0,2*pi,length.out=100)), y=.23+.01*sin(seq(0,2*pi,length.out=100)), linetype = 3, hjust =0, vjust = 0) +
  annotate("text", x=.37, y=.22, label = "Mean Estimate 95% CI", size = 2.5, hjust = 0, vjust = 0) 
  #annotate("path", x=c(.34,.36), y=.25, hjust =0, vjust = 0) +
  #annotate("text", x=.37, y=.25, label = "Marginal 95% HDI", size = 2.5, hjust = 0, vjust = 0) 
   
#+ xlab("ttlc takeover increase with ttlc onset (s)") + ylab("") + remove_yticks

print(predplot)

#ggsave("predictive_distribution_maineffects_ttlc.png", plot = predplot, dev = "png", width = 10, height = 10, units = "cm", dpi = 300, type = "cairo")
```

```{r, hypotheticals}

off_tangent <- function(b, w = 1.5, r = 60, v = 8){
  b = b / 180 * pi
  
  #ttlc = sqrt(w*(2*r + sign(b)*w)/(abs(b)*r*v))
  ttlc = sqrt(w*(2*r + w)/(v^2))
}

#http://www.standardsforhighways.co.uk/ha/standards/dmrb/vol6/section1/CD%20109%20Highway%20link%20design-web.pdf
#table 2.10 of above
#desirable R (superelevation 5%)
#Table 4.5
#motorway speed A,2 steps relaxation
#motorway speed B, 3 steps relaxation
#all purpose speed A, 3 steps 
#all purpose speed B, 4 steps.
#60 = slow rural road (37 mph)
#120 = speed limit (75)
kph = c(120, 120, 100, 85, 70, 60, 50)
ms = kph / 3.6
radii = c(3000, 2040,1020, 720, 510, 360, 255, 180)
yawrate = ms/radii
bias = ((yawrate) * 180) / pi
bias = bias * -1

tests <- data.frame("radii" = radii, "kph" = kph, "ms" = ms, "yawrate" = yawrate, "bias" = bias)
tests <- tests %>% 
  mutate(ttlc_tangent = off_tangent(b = bias, w = 1.5, r = radii, v = ms),
        ttlc_calc =  ttlc_from_offset(b = bias, w = 1.5, r= radii, v = ms))

ttlc_onset <- as.vector(tests$ttlc_tangent)
ttlc_onset <- seq(.5, to = 10, by = .1)
cogload <- c("noload","load")
pred_list <- expand_grid(ttlc_onset, cogload)

post <- posterior_samples(MOD)
modes <- post %>% 
  sapply(.,Mode)

map_mu_noload <- modes["b_Intercept"] + modes["b_ttlc_onset"]*ttlc_onset + 
  modes["b_cogloadload"]*0 + modes["b_ttlc_onset:cogloadload"]*(ttlc_onset*0)
map_mu_load <- modes["b_Intercept"] + modes["b_ttlc_onset"]*ttlc_onset + 
  modes["b_cogloadload"]*1 + modes["b_ttlc_onset:cogloadload"]*(ttlc_onset*1)

map_sig_noload <- modes["b_sigma_Intercept"] + modes["b_sigma_ttlc_onset"]*ttlc_onset + 
  modes["b_sigma_cogloadload"]*0 + modes["b_sigma_ttlc_onset:cogloadload"]*(ttlc_onset*0)

map_sig_load <- modes["b_sigma_Intercept"] + modes["b_sigma_ttlc_onset"]*ttlc_onset + 
  modes["b_sigma_cogloadload"]*1 + modes["b_sigma_ttlc_onset:cogloadload"]*(ttlc_onset*1)

#estimate pcross 
noloaddf <- data.frame("ttlc_onset" = ttlc_onset, "mu" = map_mu_noload, "sigma" = map_sig_noload) %>% 
  mutate(pcross = pnorm(0, mu, sigma))
loaddf <- data.frame("ttlc_onset" = ttlc_onset, "mu" = map_mu_load, "sigma" = map_sig_load) %>% 
  mutate(pcross = pnorm(0, mu, sigma))


#estimate pcross for random effects.
varcorr <- VarCorr(MOD)
cov_mat <- varcorr[["ppid"]][["cov"]][,1,] #only estimates
mu_cov <- cov_mat[1:4,1:4]
sig_cov <- cov_mat[5:7,5:7]

mu_dist <- as.data.frame(MASS::mvrnorm(9000, c(modes["b_Intercept"], modes["b_ttlc_onset"], modes["b_cogloadload"],
                                               modes["b_ttlc_onset:cogloadload"]), mu_cov))


sig_dist <- as.data.frame(MASS::mvrnorm(9000, c(modes["b_sigma_Intercept"], modes["b_sigma_ttlc_onset"],
                                                modes["b_sigma_cogloadload"]), sig_cov))


mu_predict <- array(mu_dist, dim = c(dim(mu_dist),length(ttlc_onset)), dimnames = c(1:9000, colnames(mu_dist), ttlc_onset))

map_mu_noload <- modes["b_Intercept"] + modes["b_ttlc_onset"]*ttlc_onset + 
  modes["b_cogloadload"]*0 + modes["b_ttlc_onset:cogloadload"]*(ttlc_onset*0)
map_mu_load <- modes["b_Intercept"] + modes["b_ttlc_onset"]*ttlc_onset + 
  modes["b_cogloadload"]*1 + modes["b_ttlc_onset:cogloadload"]*(ttlc_onset*1)


for (to in ttlc_onset){
  varname <- paste(to, "load", sep="_")
  
  mu_dist[[varname]] <- with(mu_dist, b_Intercept + b_ttlc_onset*to + b_cogloadload*1 + `b_ttlc_onset:cogloadload`*(to*1))
  sig_dist[[varname]] <- with(sig_dist, b_sigma_Intercept + b_sigma_ttlc_onset*to + b_sigma_cogloadload*1)
  
  
  varname <- paste(to, "noload", sep="_")
  mu_dist[[varname]] <- with(mu_dist, b_Intercept + b_ttlc_onset*to + b_cogloadload*0 + `b_ttlc_onset:cogloadload`*(to*0))
  sig_dist[[varname]] <- with(sig_dist, b_sigma_Intercept + b_sigma_ttlc_onset*to + b_sigma_cogloadload*0)
}
    
    
mu_long <- mu_dist %>% 
  pivot_longer(-starts_with('b'),
               names_to = c("ttlc_onset","cogload"),
               names_sep = "_",
               values_to = "mu")

sig_long <- sig_dist %>% 
  pivot_longer(-starts_with('b'),
               names_to = c("ttlc_onset","cogload"),
               names_sep = "_",
               values_to = "sigma")


ggplot(data = noloaddf, aes(x = ttlc_onset, y = pcross)) +
  geom_line(col = "blue") +
  geom_line(data = loaddf, col = "red") +
  geom_vline(xintercept = c(2.3, 1.6), col = "grey40", linetype = 3) +
  #annotate("text", x = 2.3, y = 6, label = "Sharp Motorway", hjust = .5, vjust = 0, size = 2) +
  #annotate("text", x = 1.6, y = 5, label = "Sharp Rural", hjust = .5, vjust = 0, size = 2) +
  theme_classic() +
  ylab("Probability of Exiting Road Before Takeover") +
  xlab(expression("TTLC"["Failure"])) +
  coord_cartesian(xlim = c(.5, 10), ylim = c(0,.005)) 
  

#the above is our MAP coefficent P cross. But to have the uncertainty intervals we need to simulate the pcross distribution for every row of the posterior samples.
  



```

```{r, take2}

#This attempt simulates a pcross for each row of the posterior sampels. A single row of the posterior samples is an estimate of the mean values of the coefficients, with the covariance baked in to it.

library(bayestestR)
post <- posterior_samples(MOD)
samples <- as.data.frame(MOD[["fit"]]@sim[["samples"]][[1]])
samples <- samples[1001:10000, ]



hist(samples$lp__)
modelp <- Mode(samples$lp__)
diff <- modelp -samples$lp__
idx <- which.min(abs(diff))

pars <- parnames(MOD)[1:23]

mymap <- sapply(samples, map_estimate)
mymaps <- data.frame("parameters" = names(mymap), "MAP" = mymap)
map_params1 <- samples[idx, ]
MAP <- map_estimate(MOD,  parameters = pars, effects = "all", component = "all")
map_params <- mymaps %>% 
  pivot_wider(names_from = "parameters",
              values_from = "MAP")


###### population means without random effects (also without uncertainty) ##############

map_mu_noload <- map_params$b_Intercept + map_params$b_ttlc_onset*ttlc_onset + 
  map_params$b_cogloadload*0 + map_params$b_sigma_ttlc_onset.cogloadload*(ttlc_onset*0)
map_mu_load <- map_params$b_Intercept + map_params$b_ttlc_onset*ttlc_onset + 
  map_params$b_cogloadload*1 + map_params$b_sigma_ttlc_onset.cogloadload*(ttlc_onset*1)

map_sig_noload <- map_params$b_sigma_Intercept + map_params$b_sigma_ttlc_onset*ttlc_onset + 
  map_params$b_sigma_cogloadload*0 

map_sig_load <- map_params$b_sigma_Intercept + map_params$b_sigma_ttlc_onset*ttlc_onset + 
  map_params$b_sigma_cogloadload*1

#estimate pcross 
noloaddf <- data.frame("ttlc_onset" = ttlc_onset, "mu" = map_mu_noload, "sigma" = map_sig_noload) %>% 
  mutate(pcross = pnorm(0, mu, sigma))
loaddf <- data.frame("ttlc_onset" = ttlc_onset, "mu" = map_mu_load, "sigma" = map_sig_load) %>% 
  mutate(pcross = pnorm(0, mu, sigma))

############ including random effects #####################

sim_avg_pcross <- function(row, nsamples){
  

    #for mu
  #intercept
  cov_int_to <- with(row, sd_ppid__Intercept*sd_ppid__ttlc_onset*cor_ppid__Intercept__ttlc_onset)
  cov_int_cl <- with(row, sd_ppid__Intercept*sd_ppid__cogloadload*cor_ppid__Intercept__cogloadload)
  cov_int_to.cl <- with(row, sd_ppid__Intercept*sd_ppid__ttlc_onset.cogloadload*cor_ppid__Intercept__ttlc_onset.cogloadload)
  
  #ttlc
  cov_to_cl <- with(row,sd_ppid__ttlc_onset*sd_ppid__cogloadload*cor_ppid__ttlc_onset__cogloadload)
  cov_to_to.cl <- with(row,sd_ppid__ttlc_onset*sd_ppid__ttlc_onset.cogloadload*cor_ppid__ttlc_onset__ttlc_onset.cogloadload)
  
  #cl
  cov_cl_to.cl <- with(row, sd_ppid__cogloadload*sd_ppid__ttlc_onset.cogloadload*cor_ppid__cogloadload__ttlc_onset.cogloadload)
  
  
  cov_mat_mu = with(row, matrix(
    c(sd_ppid__Intercept^2, cov_int_to, cov_int_cl, cov_int_to.cl,
      cov_int_to, sd_ppid__ttlc_onset^2, cov_to_cl, cov_to_to.cl,
      cov_int_cl, cov_to_cl, sd_ppid__cogloadload^2, cov_cl_to.cl,
      cov_int_to.cl, cov_to_to.cl, cov_cl_to.cl, sd_ppid__ttlc_onset.cogloadload^2), ncol = 4))
  
  
  print(cov_mat_mu)
  mu_dist <- as.data.frame(MASS::mvrnorm(nsamples, c(row$b_Intercept, row$b_ttlc_onset, row$b_cogloadload, row$b_ttlc_onset.cogloadload), cov_mat_mu))
  
  colnames(mu_dist) <- c("b_Intercept","b_ttlc_onset","b_cogloadload","b_ttlc_onset.cogloadload")
  mu_dist$pp <- 1:nsamples
  
  #sigma 
  cov_int_to <- with(row, sd_ppid__sigma_Intercept*sd_ppid__sigma_ttlc_onset*cor_ppid__sigma_Intercept__sigma_ttlc_onset)
  cov_int_cl <- with(row, sd_ppid__sigma_Intercept*sd_ppid__sigma_cogloadload*cor_ppid__sigma_Intercept__sigma_cogloadload)
  cov_to_cl <- with(row,sd_ppid__sigma_ttlc_onset*sd_ppid__sigma_cogloadload*cor_ppid__sigma_ttlc_onset__sigma_cogloadload)
  
  cov_mat_sig = with(row, matrix(
    c(sd_ppid__sigma_Intercept^2, cov_int_to, cov_int_cl, 
      cov_int_to, sd_ppid__sigma_ttlc_onset^2, cov_to_cl, 
      cov_int_cl, cov_to_cl, sd_ppid__sigma_cogloadload^2), ncol = 3))
  
  
  sig_dist <- as.data.frame(MASS::mvrnorm(nsamples, c(row$b_sigma_Intercept, row$b_sigma_ttlc_onset, row$b_sigma_cogloadload), cov_mat_sig))
  
  colnames(sig_dist) <- c("b_sigma_Intercept","b_sigma_ttlc_onset","b_sigma_cogloadload")
  sig_dist$pp <- 1:nsamples
  
  
  for (to in ttlc_onset){
    varname <- paste(to, "load", sep="_")
    
    mu_dist[[varname]] <- with(mu_dist, b_Intercept + b_ttlc_onset*to + b_cogloadload*1 + `b_ttlc_onset.cogloadload`*(to*1))
    sig_dist[[varname]] <- with(sig_dist, b_sigma_Intercept + b_sigma_ttlc_onset*to + b_sigma_cogloadload*1)
    
    
    varname <- paste(to, "noload", sep="_")
    mu_dist[[varname]] <- with(mu_dist, b_Intercept + b_ttlc_onset*to + b_cogloadload*0 + `b_ttlc_onset.cogloadload`*(to*0))
    sig_dist[[varname]] <- with(sig_dist, b_sigma_Intercept + b_sigma_ttlc_onset*to + b_sigma_cogloadload*0)
  }
      
      
  mu_long <- mu_dist %>% 
    pivot_longer(-c(starts_with('b'),'pp'),
                 names_to = c("ttlc_onset","cogload"),
                 names_sep = "_",
                 values_to = "mu")
  
  sig_long <- sig_dist %>% 
    pivot_longer(-c(starts_with('b'),'pp'),
                 names_to = c("ttlc_onset","cogload"),
                 names_sep = "_",
                 values_to = "sigma")
  
  #hack just get positive sigma
  #sig_long <- filter(sig_long, sigma > 0)
  
  #simulate participants. since mu and sigma are considered independent in the model, just randomly draw from them separately
  mu_long$sigma <- sig_long$sigma
  
  mu_long <- mu_long %>% 
    filter(sigma > 0) %>% 
    group_by(pp, ttlc_onset, cogload) %>% 
    mutate(pcross = pnorm(0, mu, sigma))
  
  
  pcross_avg <- mu_long %>% 
    ungroup() %>% 
    group_by(ttlc_onset, cogload) %>% 
    summarise(pcross = mean(pcross, na.rm = TRUE))
  pcross_avg$ttlc_onset <- as.double(pcross_avg$ttlc_onset)

  
  return(pcross_avg)
}


#sims = 1000
#draws <- samples[sample(nrow(samples), sims, replace = FALSE), ]


#below simulates the random effects with uncertainty by looping through all the posterioer estimates. These are truly predictive intervals but for our pcross.
for (row in 1:nrow(samples)) {
  time <- Sys.time()
  print(row)
  simrow <- samples[row,]
  row_dists <- predict_coeff_dist(simrow, 500) #coefficients.
  row_dpars <- predict_condition_dpars(ttlc_onset, row_dists) #dpars predicted from regmodel
  p_c <- avg_pcross(row_dpars)
  varname <- paste0("draw_",row)
  if (row == 1){
    pc <- p_c
  }
  pc[[varname]] <- p_c$pcross
  print(Sys.time() - time)
}

pc <- pc %>% 
  pivot_longer(-c('ttlc_onset','cogload','pcross'),
               names_to = "draw",
               values_to = "val")

save(pc, file = 'pcross.rda')
load('pcross.rda')

onesd = .683
onesd.l = .5 - (onesd/2)
onesd.u = .5 + (onesd/2)
twosd = .955
twosd.l = .5 - (twosd/2)
twosd.u = .5 + (twosd/2)

pc_bounds <- pc %>% 
  ungroup() %>% 
  group_by(ttlc_onset, cogload) %>% 
  summarise(Estimate = mean(val),
            Q2.25 = qi(val, .width = twosd)[1],
            Q15.85 = qi(val, .width = onesd)[1],
            Q84.15 = qi(val, .width = onesd)[2],
            Q97.75 = qi(val, .width = twosd)[2])




psim <- ggplot() +
  #geom_line(col = "blue") +
 #geom_line(data = loaddf, col = "red") +
 # geom_line(data = toplot, aes(x = ttlc_onset, y =pcross, col = cogload, group = interaction(pp,cogload)), inherit.aes = FALSE, alpha = .2) +
  
  #geom_line(data = pc_avg, aes(x = ttlc_onset, y =pcross, col = cogload, group = cogload), inherit.aes = FALSE, alpha = 1) +
  #geom_line(data = pc, aes(x = ttlc_onset, y =val, col = cogload, group = interaction(draw,cogload)), inherit.aes = FALSE, alpha = .2) +  

    geom_line(data = pc_bounds, aes(x = ttlc_onset, y =Estimate, col = cogload, group = cogload), inherit.aes = FALSE, alpha = 1, linetype = 1) +  
  
  geom_ribbon(data =pc_bounds, aes(x=ttlc_onset, ymin = Q2.25, ymax = Q97.75, fill = cogload), col = NA, alpha = .1, inherit.aes = FALSE) + #99% band
  geom_ribbon(data = pc_bounds, aes(x = ttlc_onset, ymin = Q15.85, ymax = Q84.15, fill = cogload), alpha = .2, inherit.aes = FALSE) + #50% band
  
  geom_vline(xintercept = c(2.3, 1.6), col = "grey40", linetype = 3) +
  annotate("text", x = 2.3, y = .075, label = "Sharp Motorway", hjust = .5, vjust = 0, size = 2) +
  annotate("text", x = 1.6, y = .08, label = "Sharp Rural", hjust = .5, vjust = 0, size = 2) +
  theme_classic() +
  ylab("Probability of Exiting Road Before Takeover") +
  xlab(expression("TTLC"["Failure"])) +
  coord_cartesian(xlim = c(.5, 10), ylim = c(0,.12)) +
  scale_color_manual(values = cogload_cols, guide = guide_legend(reverse = FALSE)) + scale_fill_manual(values = cogload_cols) + guides(fill = FALSE) 


show(psim)
ggsave("simulated_pcross.png", plot = psim, dev = "png", width = 18, height = 10, units = "cm", dpi = 300, type = "cairo")

```


```{r, effect on tltlc takeover variance, eval = FALSE}

ttlc_onset <- seq(1, to = 13, by = .1)
cogload <- c("noload","load")
pred_list <- expand_grid(ttlc_onset, cogload)
preds <- fitted(MOD, newdata=pred_list, summary=TRUE, re_formula = NA, probs = c(.005, 0.025, .25, .75, 0.975, .995), dpar = "sigma") %>% 
  cbind(pred_list) 

cols = c("#16bf81", "#c21756")
mn_ribbon <- ggplot(preds, aes(x = ttlc_onset, group = cogload, col = cogload)) +
 # geom_line(aes(y = exp(Q0.5)), alpha = .2, linetype = 2) +
#    geom_line(aes(y = exp(Q99.5)), alpha = .2, linetype = 2) +
    geom_line(aes(y = Q2.5), alpha = .5, linetype = 2) +
    geom_line(aes(y = Q97.5), alpha = .5, linetype = 2) +
#    geom_line(aes(y = exp(Q25)), alpha = .75, linetype = 2) +
#    geom_line(aes(y = exp(Q75)), alpha = .75, linetype = 2) +
    scale_colour_manual(values = cols) +
    geom_line(aes(y = Estimate)) +
  theme_classic() +
  xlab("ttlc onset (s)") + ylab(expression(paste(sigma, " (ttlc takeover)", sep = ""))) + #ylim(0,6) +
  theme(legend.position = c(0.2, 0.8))

print(mn_ribbon)

remove_yticks <-  theme(axis.text.y = element_blank(),
  axis.ticks.y = element_blank())


#ttlc
b = "b_sigma_ttlc_onset"
ps = posterior_samples(MOD, pars = b)
ps_hdi <- mode_hdi(ps[[b]], .width = .95) 
ttlcfixplot <- ggplot() +
  geom_histogram(data = ps, aes_string(x = b), bins = 60, fill = "skyblue3", alpha = 1)+
  geom_segment(data=ps_hdi, aes(x=ymin, y=0, xend=ymax, yend=0), size=1) + 
  geom_point(data=ps_hdi, aes(x=y, y=0), size=2) +
  theme_classic() + 
  geom_vline(xintercept=0, linetype="dashed", col = "grey40") +
  xlim(-.1, .2) + xlab("increase in ttlc takeover \nstandard deviation with ttlc onset (s)") + ylab("") + remove_yticks

print(ttlcfixplot)

#cogload
b = "b_sigma_cogloadload"
ps = posterior_samples(MOD, pars = b)
ps_hdi <- mode_hdi(ps[[b]], .width = .95) 
clfixplot <- ggplot() + 
  geom_histogram(data = ps, aes_string(x = b), bins = 60, fill = "seagreen4", alpha = 1)+
  geom_segment(data=ps_hdi, aes(x=ymin, y=0, xend=ymax, yend=0), size=1) + 
  geom_point(data=ps_hdi, aes(x=y, y=0), size=2) +
  theme_classic() + 
  geom_vline(xintercept=0, linetype="dashed", col = "grey40") + 
  xlim(-.25, .05) + xlab("decrease in sd(ttlc takeover)\n when load removed (s)") + ylab("") + remove_yticks
  
print(clfixplot)

  
#cogload * ttlc
b = "b_sigma_ttlc_onset:cogloadload"
ps = posterior_samples(MOD, pars = b)
ps_hdi <- mode_hdi(ps[[b]], .width = .95) 
interplot <- ggplot() +
  geom_histogram(data = ps, aes(x = .data[[b]]), bins = 60, fill = "turquoise4", alpha = 1)+
  geom_segment(data=ps_hdi, aes(x=ymin, y=0, xend=ymax, yend=0), size=1) + 
  geom_point(data=ps_hdi, aes(x=y, y=0), size=2) +
  theme_classic() +
  geom_vline(xintercept=0, linetype="dashed", col = "grey40")+
  xlim(-.05, .05) + xlab("change in ttlc slope on \nsd(takeover) when load removed") + ylab("") +remove_yticks

print(interplot)



b = "cor_ppid__sigma_ttlc_onset__sigma_cogloadload"
cor = posterior_samples(MOD, pars = b)
cor_hdi <- mode_hdi(cor[[b]], .width = .95) 

corplot <- ggplot() +
  geom_histogram(data = cor, aes_string(x = b), bins = 60, fill = "turquoise4", alpha = 1)+
  geom_segment(data=cor_hdi, aes(x=ymin, y=0, xend=ymax, yend=0), size=1) + 
  geom_point(data=cor_hdi, aes(x=y, y=0), size=2) +
  theme_classic() +
  geom_vline(xintercept=0, linetype="dashed", col = "grey40") +
  xlab("Correlation between slope and load") + ylab("") +remove_yticks

print(corplot)


right_col <- plot_grid(ttlcfixplot, clfixplot, corplot, nrow = 3, labels = c("B","C","D"), label_size = 12)
full_grid <- plot_grid(mn_ribbon, right_col, ncol = 2, labels = c("A",""), label_size = 12, rel_widths = c(1,.75))
print(full_grid)

ggsave("population_coefficient_variance_means_ttlc.png", plot = full_grid, dev = "png", width = 18, height = 10, units = "cm", dpi = 300, type = "cairo")

```

```{r, same as above but with predicted distributions for variance}

ttlc_onset <- seq(1, to = 13, by = .1)
cogload <- c("noload","load")
ppid <- 50
pred_list <- expand_grid(ttlc_onset, cogload, ppid)
preds <- fitted(MOD, newdata=pred_list, summary=TRUE, re_formula = NULL, allow_new_levels = TRUE, probs = c(.005, 0.025, .25, .75, 0.975, .995), dpar = "sigma") %>% 
  cbind(pred_list) 

cols = c("#16bf81", "#c21756")
mn_ribbon <- ggplot(preds, aes(x = ttlc_onset, group = cogload, col = cogload)) +
 # geom_line(aes(y = exp(Q0.5)), alpha = .2, linetype = 2) +
#    geom_line(aes(y = exp(Q99.5)), alpha = .2, linetype = 2) +
    geom_line(aes(y = Q2.5), alpha = .5, linetype = 2) +
    geom_line(aes(y = Q97.5), alpha = .5, linetype = 2) +
#    geom_line(aes(y = exp(Q25)), alpha = .75, linetype = 2) +
#    geom_line(aes(y = exp(Q75)), alpha = .75, linetype = 2) +
    scale_colour_manual(values = cols) +
    geom_line(aes(y = Estimate)) +
  theme_classic() +
  xlab("ttlc onset (s)") + ylab(expression(paste(sigma, " (ttlc takeover)", sep = ""))) + #ylim(0,6) +
  theme(legend.position = c(0.2, 0.8))

print(mn_ribbon)
#there's a bug here with the predicted regression line for a new participant at really low ttlc values

#plot distribution of main effects and interactions.

#get distribution for unseen participant.
#sample from distribution.

#with a little help from Kurtz: https://bookdown.org/ajkurz/Statistical_Rethinking_recoded/multilevel-models.html

post <- posterior_samples(MOD)


mn = "b_sigma_ttlc_onset"
sd = "sd_ppid__sigma_ttlc_onset"
new_obs <- rnorm(n= nrow(post), mean = post[[mn]], sd   = post[[sd]])
new_obs_hdi <- mode_hdi(new_obs, width = .95)

#ttlc
ttlcfixplot <- ggplot() +
  geom_histogram(data = data.frame(new_obs), aes_string(x = new_obs), bins = 60, fill = "skyblue3", alpha = 1)+
  geom_segment(data=new_obs_hdi, aes(x=ymin, y=0, xend=ymax, yend=0), size=1) + 
  geom_point(data=new_obs_hdi, aes(x=y, y=0), size=2) +
  theme_classic() + 
  geom_vline(xintercept=0, linetype="dashed", col = "grey40") +
xlab("ttlc slope of unseen participants (s)") + ylab("") + remove_yticks

print(ttlcfixplot)

#cogload

mn = "b_sigma_cogloadload"
sd = "sd_ppid__sigma_cogloadload"
new_obs <- rnorm(n= nrow(post), mean = post[[mn]], sd   = post[[sd]])
new_obs_hdi <- mode_hdi(new_obs, width = .95)

clfixplot <- ggplot() +
  geom_histogram(data = data.frame(new_obs), aes_string(x = new_obs), bins = 60, fill = "seagreen4", alpha = 1)+
  geom_segment(data=new_obs_hdi, aes(x=ymin, y=0, xend=ymax, yend=0), size=1) + 
  geom_point(data=new_obs_hdi, aes(x=y, y=0), size=2) +
  theme_classic() + 
  geom_vline(xintercept=0, linetype="dashed", col = "grey40") +
  xlab("cogload effect of unseen participants (s)") + ylab("") + remove_yticks
  
print(clfixplot)


#participant variability 
  
#cogload * ttlc

varplot <- ggplot(data = post) +
  geom_histogram(aes(x = sd_ppid__sigma_ttlc_onset), bins = 60, fill = "skyblue3", alpha = .5)+
  geom_histogram(aes(x = sd_ppid__sigma_cogloadload), bins = 60, fill = "seagreen4", alpha = .5)+
  theme_classic() +
  xlab("between participant variability") + ylab("") +remove_yticks

print(varplot)



right_col <- plot_grid(ttlcfixplot, clfixplot, varplot, nrow = 3, labels = c("B","C","D"), label_size = 12)
full_grid <- plot_grid(mn_ribbon, right_col, ncol = 2, labels = c("A",""), label_size = 12, rel_widths = c(1,.75))
print(full_grid)

ggsave("population_coefficient_newparticipants_variance.png", plot = full_grid, dev = "png", width = 18, height = 10, units = "cm", dpi = 300, type = "cairo")
  
```



```{r, old useful code, eval = FALSE}


nl_bf_sig2 <- bf(log_RT ~ log((b1 * ttlc_calc) + (b2 * cogload)),  sigma ~ 1 + ttlc_calc + cogload,
            b1 ~1, b2 ~ 1, nl = TRUE)

prior2 = c(prior(normal(0, 4), nlpar = "b1"),
    prior(normal(0, 4), nlpar = "b2"))

nl1_sig2 = brm(data = only_responses, formula = nl_bf_sig2, prior = prior2, family = gaussian())

summary(nl1_sig2)
loo(nl1_sig2, nl1_sig)
loo_model_weights(nl1_sig2, nl1_sig)
pp_check(nl1_sig2)

nl_bf_sig3 <- bf(log_RT ~ log((b1 * ttlc_calc) + (b2 * cogload)),  sigma ~  0 + ttlc_calc + cogload + (1 | ppid),
            b1 ~1, b2 ~ 1, nl = TRUE)

prior2 = c(prior(normal(0, 4), nlpar = "b1"),
    prior(normal(0, 4), nlpar = "b2"))

nl1_sig3 = brm(data = only_responses, formula = nl_bf_sig3, prior = prior2, family = gaussian(),
               iter = 5000, cores = 4, refresh = 500, chains = 4, warmup = 1000, control = list(adapt_delta = 0.90))

summary(nl1_sig3)
loo(nl1_sig3, nl1_sig2, nl1_sig)
loo_model_weights(nl1_sig3, nl1_sig2, nl1_sig)
pp_check(nl1_sig3)

nl_bf_sig4 <- bf(log_RT ~ log((b1 * ttlc_calc) + (b2 * cogload) + (b3*ttlc_calc*cogload)),  sigma ~  0 + ttlc_calc + cogload + (1 | ppid),
            b1 ~1, b2 ~ 1, b3 ~ 1, nl = TRUE)

prior3 = c(prior(normal(0, 3), nlpar = "b1"),
    prior(normal(0, 3), nlpar = "b2"),
    prior(normal(0, 3), nlpar = "b3"))

nl1_sig4 = brm(data = only_responses, formula = nl_bf_sig4, prior = prior3, family = gaussian(),
               iter = 5000, cores = 4, refresh = 500, chains = 4, warmup = 1000, control = list(adapt_delta = 0.90))

#improvement.
summary(nl1_sig4)
loo(nl1_sig4, nl1_sig3, nl1_sig2, nl1_sig)
loo_model_weights(nl1_sig4, nl1_sig3, nl1_sig2, nl1_sig)
pp_check(nl1_sig4)

nl_bf_sig4.1 <- bf(log_RT ~ log((b1 * ttlc_calc) + (b2 * cogload) + (b3*ttlc_calc*cogload)),  sigma ~  1 + ttlc_calc + cogload + (1 | ppid),
            b1 ~1, b2 ~ 1, b3 ~ 1, nl = TRUE)

nl1_sig4.1 = brm(data = only_responses, formula = nl_bf_sig4.1, prior = prior3, family = gaussian(),
               iter = 5000, cores = 4, refresh = 500, chains = 4, warmup = 1000, control = list(adapt_delta = 0.90))

#should sigma have an intercept? LOO says that the intercept 4.1 is worse than the non-intercept 4
summary(nl1_sig4.1)
pp_check(nl1_sig4.1)
loo(nl1_sig4, nl1_sig4.1)


nl_bf_sig5 <- bf(log_RT ~ log((b1 * ttlc_calc) + (b2 * cogload) + (b3*ttlc_calc*cogload)),  sigma ~  0 + ttlc_calc + cogload + (1 | ppid),
            b1 ~ 1 + (1 | ppid), b2 ~ 1 + (1 | ppid), b3 ~ 1 + (1 | ppid), nl = TRUE)

prior3 = c(prior(normal(0, 3), nlpar = "b1"),
    prior(normal(0, 3), nlpar = "b2"),
    prior(normal(0, 3), nlpar = "b3"))

nl1_sig5 = brm(data = only_responses, formula = nl_bf_sig5, prior = prior3, family = gaussian(),
               iter = 10000, cores = 4, refresh = 500, chains = 1, warmup = 1000, control = list(adapt_delta = 0.99))

summary(nl1_sig5)
loo(nl1_sig5, nl1_sig4)
loo_model_weights(nl1_sig5, nl1_sig4, nl1_sig3, nl1_sig2, nl1_sig)
pp_check(nl1_sig5)
plot_ribbon(nl1_sig5, only_responses, 'nl5_ribbon.png', 'ttlc_calc','RT')
plot_hist(nl1_sig5, only_responses, 'nl5_hist.png', 'RT', 'time_remaining')
save(nl1_sig5, file ='nl5.rda')

nl_bf_sig5.trunc <- bf(log_RT | trunc(ub = log_TR) ~ log((b1 * ttlc_calc) + (b2 * cogload) + (b3*ttlc_calc*cogload)),  sigma ~  0 + ttlc_calc + cogload + (1 | ppid),
            b1 ~ 1 + (1 | ppid), b2 ~ 1 + (1 | ppid), b3 ~ 1 + (1 | ppid), nl = TRUE)

nl1_sig5.trunc = brm(data = only_responses, formula = nl_bf_sig5.trunc, prior = prior3, family = gaussian(),
               iter = 10000, cores = 4, refresh = 500, chains = 1, warmup = 1000, control = list(adapt_delta = 0.99))
#mu_identity, sigma_log

summary(nl1_sig5.trunc)

save(nl1_sig5.trunc, file ='nl5_trunc.rda')

```

