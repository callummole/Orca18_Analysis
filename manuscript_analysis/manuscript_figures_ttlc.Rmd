---
title: "Orca Silent Failures, Companion to Manuscript"
author: "Callum Mole"
date: "23/04/2020"
output: html_document
---


```{r Load preliminaries, include=FALSE, warning=FALSE}

library("tidyverse")
library("brms")
library("rstan")
library("tidybayes")
library("wesanderson")
library("cowplot")
library(latex2exp)
library(bayestestR)
library(grid)
library(ggridges)

#blue and red from matplotlib tab10 default color cycle.
#red = #d62728
#blue = #1f77b4
cogload_cols = c("#1f77b4","#d62728")

#balanced colours are, in order of high to low severity:

#pink = #e377c2
#orange = #ff7f0e
#green = #2ca02c
#purple = #9467bd
balanced_cols = c("#e377c2","#ff7f0e","#2ca02c","#9467bd")

#for noload plots
pred_col = "grey60"
data_col = "black"

#add theme here
theme_orca <- theme(text = element_text(family = "sans", size = 9),
                    axis.text = element_text(family = "sans", size = 8),
                    axis.title = element_text(family = "sans", size = 9),
                    ) 

text_multiplier <- ggplot2:::.pt
ansize = 7/text_multiplier


REFIT = FALSE #put to true if you want to refit model and resimulate P(Exit)

```


```{r, load data}


setwd(dirname(rstudioapi::getActiveDocumentContext()$path))

#load steer data

steerdata <- readRDS("../Data/collated_steering.rds")  

steerdata <- steerdata %>% 
  rename(swv = swa) %>% 
  mutate(swa = swv * 90)

steerdata$autoflag<- plyr::mapvalues(steerdata$autoflag, from = c("True", "False"), to = c("TRUE", "FALSE"))

#mirror data
steerdata <- steerdata %>% 
  mutate(world_x_mirrored = if_else(bend == -1, world_x * -1, world_x),
         swa_mirrored = if_else(bend == -1, swa * -1, swa),
         swv_mirrored = if_else(bend == -1, swv * -1, swv),
         sb_mirrored = if_else(bend == -1, steeringbias * -1, steeringbias))



TLC_from_offset <- function(b, w = 1.5, r = 80, v = 8){
  b = b / 180 * pi
  
  TLC = sqrt(w*(2*r + sign(b)*w)/(abs(b)*r*v))
}

steerdata <- steerdata %>% 
  mutate(TLC_calc = TLC_from_offset(sab))


#add RT and disengage flag.
disengage_RT <- function(onsettime, timestamp_trial, autoflag){
  
  #pick first frame where autoflag == false, then take the timestamp and minus the onset_time
  auto_false <- which(autoflag == "FALSE")
  disengage_index <- first(auto_false)
  disengage_trialtime <- timestamp_trial[disengage_index]
  onset_time <- first(onsettime)
  RT <- disengage_trialtime - onset_time #can be negative
  return(RT)
  
}

#calculate RT
steerdata <- steerdata  %>% 
  group_by(ppid, sab, cogload, trialn) %>% 
  mutate(RT = disengage_RT(onsettime, timestamp_trial, autoflag),
         disengaged = ifelse(is.na(RT), 0, 1) #whether or not they actually took over.
  )

#create unique trial id
steerdata <- steerdata %>% 
  mutate(trialid = paste(ppid, cogload, trialn, sep = "_"))

steerdata$cogload <- as.factor(steerdata$cogload)

#rename cogload factors so that it ameks sense
steerdata$cogload<- plyr::mapvalues(steerdata$cogload, from = c("None", "Middle"), to = c("noload", "load"))


data_RTs <- steerdata  %>% 
  ungroup() %>% 
  group_by(ppid, cogload, trialn) %>% 
  summarize(RT = first(RT),
            disengaged = first(disengaged), #whether or not they actually took over.
            premature = ifelse(RT <= 0, 1, 0),
            sab = first(sab),
            maxsb = max(abs(sb_mirrored)),
            onsettime = first(onsettime),
            design = first(design),
            #simTLC = first(simulated_TLC),
            autofile_i = first(autofile_i),
            TLC_calc = first(TLC_calc))
            

#simualted_TLC
sim_TLCs <- read_csv("../Post-processing/simulated_ttlcs.csv")
data_RTs <- merge(data_RTs, sim_TLCs, by =c("sab","onsettime","autofile_i"))

#add simulated TLCs.
data_RTs <- data_RTs %>% 
mutate(TLC_onset = simulated_ttlc,
        TLC_takeover = TLC_onset - RT,
        time_remaining = 15 - onsettime, 
        early = time_remaining - RT,
        TLC_end_of_trial = TLC_onset - time_remaining)  

data_RTs_cens <- data_RTs %>%
  filter(premature == 0 | is.na(premature)) %>% #takeovers before onset are uncontrolled
  mutate(censored = ifelse(is.na(TLC_takeover), -1,
                           ifelse(TLC_takeover < TLC_end_of_trial, -1, 0)))

data_RTs_cens$cogload <- relevel(data_RTs_cens$cogload, "noload")
data_RTs_cens <- filter(data_RTs_cens, ppid != 13) #13 moves the wheel pretty much every trial before they should do,
```


```{r, manuscript info}

#proportion premature
data_RTs_filtered <- filter(data_RTs, ppid != 13)
print(1 - nrow(data_RTs_cens)/ nrow(data_RTs_filtered))

print(length(unique(data_RTs_cens$TLC_onset))) #number of criticalities tested.

#proportion censored
print(1 - nrow(filter(data_RTs_cens, censored == -1)) /nrow(data_RTs_cens))


```
```{r, fit full model with specified priors}


if (REFIT){
  bf9 <- bf(TLC_takeover | trunc(ub = TLC_onset) + cens(censored) ~ 1 + TLC_onset * cogload + (1 + TLC_onset * cogload | ppid), sigma ~ 1 + log(TLC_onset) + cogload + (1 + log(TLC_onset) + cogload | ppid))

  fam <- brmsfamily("gaussian", link_sigma = "log")
  print(get_prior(bf9, data =data_RTs_cens, family=fam))

  #broad priors.
  myprior = c(set_prior("normal(0,2)", class="Intercept"), 
            set_prior("cauchy(0,1)", class="sd"),
            set_prior("normal(0,2)", class="b"))

  #there will be initial value errors due to log link on sigma. Could set initial values, but it samples eventually almost every time.
  m9.gauss <- brm(data = data_RTs_cens, formula = bf9,
                family = fam, prior = myprior, #inits = inits9,
                iter = 10000, cores = 4, refresh = 500, chains = 1, warmup = 1000)
  save(m9.gauss, file = 'mymod_simTLC.rda')  
} else {
  #save('mymod', )
  load('mymod_simTLC.rda')
}




summary(m9.gauss)
```



```{r, fig1 - visualising predictive intervals for no load, fig.width= 3.42, fig.height=2.75}

MOD <- m9.gauss


onesd = .683
onesd.l = .5 - (onesd/2)
onesd.u = .5 + (onesd/2)
twosd = .955
twosd.l = .5 - (twosd/2)
twosd.u = .5 + (twosd/2)



#avg_onset = mean(data_RTs_cens$onsettime)
#Fig1, overall predictive intervals.
TLC_onset <- seq(.1, to = 17, by = .5)
#mean_censoring <- TLC_onset - (15 - avg_onset)
#censor <- data.frame(TLC_onset, mean_censoring)
cogload <- c("noload")
pred_list <- expand_grid(TLC_onset, cogload)
preds <- predict(MOD, newdata=pred_list, summary=TRUE, allow_new_levels = TRUE, probs = c(twosd.l, onesd.l, onesd.u, twosd.u)) %>% 
  cbind(pred_list) %>%
  group_by(TLC_onset) %>% 
  mutate(Estimate = mean(Estimate),
         Q2.25 = min(Q2.25),
         Q15.85 = min(Q15.85),
         Q84.15 = min(Q84.15),
         Q97.75 = max(Q97.75))


plot_data <- data_RTs %>% 
  filter(design == "balanced") %>% 
  ungroup() %>% 
  mutate(TLC_onset_round = round(TLC_onset, digits = 1)) 
  #select(TLC_onset, TLC_onset_round) %>% 
  
ticks <- plot_data %>% 
  select(TLC_onset, TLC_onset_round) %>% 
  unique(.)


censors <- data_RTs_cens %>%
  ungroup() %>% 
  filter(cogload == "noload") %>% 
  mutate(xmin = TLC_onset - .15,
         xmax = TLC_onset + .15) %>% 
  select(TLC_onset, onsettime, TLC_end_of_trial, xmin, xmax) %>% 
  group_by(TLC_onset) %>% 
  summarise(mineot = min(TLC_end_of_trial)) 
  #filter(TLC_onset > 5 & TLC_onset < 13)

onsets <- c(5.375, 6)
censor_lines <- lapply(onsets, function(x) TLC_onset - (15 -x))


censor_m <- lm(mineot ~ poly(TLC_onset,3), data = censors)

censor_predict <- stats::predict(object = censor_m, newdata = as.data.frame(TLC_onset))

censor_col = "#bcbd22"

leg_v = .6 #vertical spacing
leg_b = 7 #starting bottom
leg_l = 1 #left align
leg_h = .35 #space between dot and text

ribbon <- ggplot(preds, aes(x = TLC_onset)) +
  geom_abline(intercept = 0, slope = 1, linetype = "dotted", col = "grey60") + #1:1 line
  geom_abline(intercept = -1, slope = 1, linetype = "dotted", col = "grey60") + #1:1 line
  annotate("text", x = 9.1, y = 9.4, label = "RT = 0 s", hjust = .5, vjust = 0, size = ansize, angle = 50, col = "grey60") +
  annotate("text", x = 10.3, y = 8.5, label = "RT = 1 s", hjust = .5, vjust = 0, size = ansize, angle = 50, col = "grey60") +
  
  
  geom_ribbon(aes(ymin = Q2.25, ymax = Q97.75), fill = pred_col, col = NA, alpha = .1) + #99% band
  geom_ribbon(aes(ymin = Q15.85, ymax = Q84.15), fill = pred_col, alpha = .3) + #50% band
  geom_line(aes(y = Estimate), col = pred_col, size = 1.5) + #mean
  
  #  
  geom_point(data = filter(data_RTs_cens, cogload == "noload", design == "random", premature == 0), aes(x = TLC_onset, y= TLC_takeover), alpha = .25, col = data_col, size = .75) + #raw data
  geom_point(data = filter(plot_data, cogload == "noload", premature == 0), aes(x = TLC_onset, y= TLC_takeover, col = factor(TLC_onset_round)), alpha = .25, size = .75) + #raw data
  
  
  geom_segment(data = censors, aes(x = TLC_onset-.1, xend = TLC_onset+.1, y = mineot, yend = mineot), size = 1, col = censor_col) +
 
  annotate("text", x = 15.8, y = 5.5, label = expression(mu), hjust = .5, vjust = 0, size = ansize) +
  annotate("text", x = 15.8, y = 3.8, label = expression(mu*"-"*sigma), hjust = .5, vjust = 0, size = ansize) +
  annotate("text", x = 15.8, y = 1.5, label = expression(mu*"-2"*sigma), hjust = .5, vjust = 0, size = ansize) +
  
  #custom legend
  annotate("point", x = leg_l, y= leg_b + (5*leg_v), col = balanced_cols[1], shape = 20, size = 1) +
  annotate("text", x = leg_l+leg_h, y = leg_b + (5*leg_v), label = "2.2 s", hjust = 0, vjust = .5, size = ansize) +
  
  annotate("point", x = leg_l, y= leg_b + (4*leg_v), col = balanced_cols[2], shape = 20, size = 1) +
  annotate("text", x = leg_l+leg_h, y = leg_b + (4*leg_v), label = "4.7 s", hjust = 0, vjust = .5, size = ansize) +
  
  annotate("point", x = leg_l, y= leg_b + (3*leg_v), col = balanced_cols[3], shape = 20, size = 1) +
  annotate("text", x = leg_l+leg_h, y = leg_b + (3*leg_v), label = "7.1 s", hjust = 0, vjust = .5, size = ansize) +
  
  annotate("point", x = leg_l, y= leg_b + (2*leg_v), col = balanced_cols[4], shape = 20, size = 1) +
  annotate("text", x = leg_l+leg_h, y = leg_b + (2*leg_v), label = "9.6 s", hjust = 0, vjust = .5, size = ansize) +
  
  annotate("point", x = leg_l, y= leg_b + (leg_v), col = pred_col, shape = 20, size = 1) +
  annotate("text", x = leg_l+leg_h, y = leg_b + (leg_v), label = "Non-Repeated", hjust = 0, vjust = .5, size = ansize) +
  
  geom_segment(aes(x = leg_l-.125, xend =leg_l + .125, y = leg_b, yend = leg_b), col = censor_col, size = 1) +
  annotate("text", x =leg_l+leg_h, y = leg_b, label = expression("TLC"["End"]), hjust = 0, vjust = .5, size = ansize) +
  
  
  theme_classic() +
  xlab(expression("TLC"["Failure"]*" (s)")) + ylab(expression("TLC"["Takeover"]*" (s)")) + 
  coord_cartesian(xlim = c(0,16), ylim = c(-1,10)) +
  scale_y_continuous(breaks = c(0,2.5,5,7.5,10), labels = c("0","2.5","5","7.5","10")) +
  scale_colour_manual(values = balanced_cols, guide = F) +
  theme_orca


print(ribbon)

ggsave("raw_predictive_noload.eps", plot = ribbon, dev = cairo_ps, width = 8.7, height = 7, units = "cm", dpi = 300)


```

```{r, coefficients plot mu}

pars = c("b_Intercept", "b_TLC_onset", "b_cogloadload", "b_TLC_onset:cogloadload", "sd_ppid__Intercept", "sd_ppid__TLC_onset", "sd_ppid__cogloadload", "sd_ppid__TLC_onset:cogloadload")

breaks = c(parse(text = TeX('$\\beta_{\\mu 0}$')),
           parse(text = TeX('$\\beta_{\\mu TF}$')),
           parse(text = TeX('$\\beta_{\\mu L}$')), 
           parse(text = TeX('$\\beta_{\\mu TF\\times L}$')),
           parse(text = TeX('$sd \\, \\beta_{\\mu 0}$')),
           parse(text = TeX('$sd \\, \\beta_{\\mu TF}$')),
           parse(text = TeX('$sd \\, \\beta_{\\mu L}$')), 
           parse(text = TeX('$sd \\, \\beta_{\\mu TF\\times L}$')))
               
draws_coef <- MOD %>% 
  posterior_samples(., pars = pars) %>% 
  gather(key = "b", value = "estimate") %>% 
  group_by(b) %>% 
  mean_hdi() %>% 
  mutate(b = fct_relevel(b, "b_Intercept", "b_TLC_onset", "b_cogloadload", "b_TLC_onset:cogloadload", "sd_ppid__Intercept", "sd_ppid__TLC_onset", "sd_ppid__cogloadload", "sd_ppid__TLC_onset:cogloadload")) %>% 
  arrange(b)


p_coef <- MOD %>% 
  posterior_samples(., pars = c("b_cogloadload","b_TLC_onset:cogloadload")) %>% 
  p_direction() 


print(draws_coef)
draws_coef$type <- c("f","f","f","f","r","r","r","r")

forest_mu <- ggplot() +
  geom_vline(xintercept = 0, linetype= "dashed", col = "grey80") +
  geom_pointintervalh(data = draws_coef,aes(y = reorder(b, desc(b)), x = estimate, xmin = .lower, xmax = .upper, col = type), fatten_point = 1, size = 1) +
  theme_classic() +
  scale_y_discrete(labels = rev(breaks))+
  scale_colour_manual(values = c("black","grey60"), guide = F) +
  ylab("Coefficients") +
  xlab("Estimate") +
  theme_orca

print(forest_mu)

ggsave("mu_coefficients.eps", plot = forest_mu, dev = cairo_ps, width = 13.2, height = 6, units = "cm", dpi = 300)


```

```{r, coefficients plot sigma}


pars = c("b_sigma_Intercept", "b_sigma_logTLC_onset",
               "b_sigma_cogloadload", "sd_ppid__sigma_Intercept", "sd_ppid__sigma_logTLC_onset",
               "sd_ppid__sigma_cogloadload")# "b_sigma_TLC_onset:cogloadload")


breaks = c(parse(text = TeX('$\\beta_{\\sigma 0}$')),
           parse(text = TeX('$\\beta_{\\sigma TF}$')),
           parse(text = TeX('$\\beta_{\\sigma L}$')), 
           parse(text = TeX('$sd \\, \\beta_{\\sigma 0}$')),
           parse(text = TeX('$sd \\, \\beta_{\\sigma TF}$')),
           parse(text = TeX('$sd \\, \\beta_{\\sigma L}$')))
           
draws_coef_sig <- MOD %>% 
  posterior_samples(., pars = pars) %>% 
  gather(key = "b", value = "estimate") %>%  
  group_by(b) %>% 
  mean_hdi() %>% 
  mutate(b = fct_relevel(b, "b_sigma_Intercept", "b_sigma_logTLC_onset",
               "b_sigma_cogloadload", "sd_ppid__sigma_Intercept", "sd_ppid__sigma_logTLC_onset",
               "sd_ppid__sigma_cogloadload")) %>% 
  arrange(b)

p_coef <- MOD %>% 
  posterior_samples(., pars = c("b_cogloadload","b_sigma_cogloadload")) %>% 
  p_direction() 


print(draws_coef_sig)
draws_coef_sig$type <- c("f","f","f","r","r","r")

exp_coef <- draws_coef_sig
exp_coef[1,2:4] <- exp(exp_coef[1,2:4])
exp_coef[3,2:4] <- exp(exp_coef[3,2:4])

print(exp_coef)

forest_sigma <- ggplot() +
  geom_vline(xintercept = 0, linetype= "dashed", col = "grey80") +
  geom_pointintervalh(data = draws_coef_sig,aes(y = reorder(b, desc(b)), x = estimate, xmin = .lower, xmax = .upper, col = type), fatten_point = 1, size = 1) +
  theme_classic() +
  scale_y_discrete(labels = rev(breaks))+
  scale_colour_manual(values = c("black","grey60"), guide = F) +
  ylab("Coefficients") +
  xlab("Estimate") +
  theme_orca

print(forest_sigma)


coef_plot <- plot_grid(forest_mu, forest_sigma, ncol =2, labels = c("A","B"), label_size = 12)
ggsave("TLC_coefficients.eps", plot = coef_plot, dev = cairo_ps, width = 13.2, height = 6, units = "cm", dpi = 300)



```

```{r, Fig 2 - predictive intervals for cogload conditions}
MOD<-m9.gauss
#parnames(m9.gauss)

onesd = .683
onesd.l = .5 - (onesd/2)
onesd.u = .5 + (onesd/2)
twosd = .955
twosd.l = .5 - (twosd/2)
twosd.u = .5 + (twosd/2)


TLC_onset <- seq(1, to = 17, by = .5)
cogload <- c("noload","load")
pred_list <- expand_grid(TLC_onset, cogload)
preds <- predict(MOD, newdata=pred_list, summary=TRUE, allow_new_levels = TRUE, probs = c(twosd.l, onesd.l, onesd.u, twosd.u)) %>% 
  cbind(pred_list) %>%
  group_by(TLC_onset, cogload) %>% 
  mutate(Estimate = mean(Estimate),
         Q2.25 = min(Q2.25),
         Q15.85 = min(Q15.85),
         Q84.15 = min(Q84.15),
         Q97.75 = max(Q97.75))


nld_xy = c(4,.6) #xy for label
ld_xy = c(6,.4)

pred_ribbon <- ggplot(preds, aes(x = TLC_onset)) +
  geom_ribbon(aes(ymin = Q2.25, ymax = Q97.75, fill = cogload), col = NA, alpha = .1) + #99% band
  geom_ribbon(aes(ymin = Q15.85, ymax = Q84.15, fill = cogload), col = NA, alpha = .3) + #50% band
  

  annotate("text", x = nld_xy[1]-1.25, y = nld_xy[2]-.7, label = expression(mu*"-2"*sigma), hjust = .6, vjust = .7, size = ansize, col = cogload_cols[1]) +
  annotate("segment", x = nld_xy[1]-1, xend = nld_xy[1], y = nld_xy[2]-.5, yend = nld_xy[2], colour = cogload_cols[1], size=.75, alpha=1, arrow=arrow(angle = 20, length = unit(0.1, "cm"), type = "closed")) +
  annotate("text",  x = ld_xy[1]-1.25, y = ld_xy[2]-.7, label = expression(mu*"-2"*sigma), hjust = .6, vjust = .7, size = ansize, col = cogload_cols[2]) +
  annotate("segment", x = ld_xy[1]-1, xend = ld_xy[1], y = ld_xy[2]-.5, yend = ld_xy[2], colour = cogload_cols[2], size=.75, alpha=1, arrow=arrow(angle = 20, length = unit(0.1, "cm"), type = "closed")) +
  
  geom_line(aes(y = Estimate, col = cogload), size = 1) + #mean
  scale_color_manual(values = rev(cogload_cols), guide = guide_legend(reverse = TRUE), labels = c('SupAuto+ACMT', 'SupAuto')) + 
  scale_fill_manual(values = rev(cogload_cols)) + guides(fill = FALSE) +
  theme_classic() +
  xlab(expression("TLC"["Failure"]*" (s)")) + ylab(expression("TLC"["Takeover"]*" (s)")) +
  coord_cartesian(ylim = c(-1,8), xlim = c(0,13)) +
  theme(legend.position = c(0.3, 0.8),
        legend.title = element_blank(),
        legend.background = element_blank()) +
  theme_orca
  
print(pred_ribbon)
```

```{r, appendix plot pp_checks, fig.width = 5.2, fig.height= 2.4}

balanced_data <- filter(data_RTs_cens, design == "balanced")
preds <- balanced_data %>% 
  add_predicted_draws(MOD, summary = FALSE)

uniq <- balanced_data %>% 
  ungroup() %>% 
  arrange(TLC_onset) %>% 
  select(TLC_onset) %>% 
  unique(.)
dat_titles<- data.frame(
  label = c(" 1.93 s", "4.21 s", "6.38 s", "8.37 s"),
  TLC_onset = uniq$TLC_onset)


cogload.names = c("SupAuto","SupAuto+ACMT")
names(cogload.names) = c("noload","load")

noload_pp_checks <- ggplot(filter(balanced_data, cogload == "noload"), aes(x = TLC_takeover, y = ..density..)) + 
  geom_density_ridges(data = filter(preds, cogload == "noload"), aes(x = .prediction, col = factor(TLC_onset)), size = 1, rel_min_height = .005) +
  geom_histogram(aes(fill = factor(TLC_onset)), alpha = .5, position = "identity", bins = 50) +
  scale_colour_manual(values = balanced_cols, guide = F) +
  scale_fill_manual(values = balanced_cols, guide = F) +
  coord_cartesian(xlim = c(0, 7), clip= "off") +
  theme_classic() +
  theme(panel.border = element_blank(), 
       panel.background = element_blank(), 
       panel.grid = element_blank(),
       strip.background = element_blank()) +
  theme_orca +
   
  ylab("Density") +
  xlab(expression("TLC"["Takeover"]*" (s)"))

load_pp_checks <- ggplot(filter(balanced_data, cogload == "load"), aes(x = TLC_takeover, y = ..density..)) + 
  geom_density_ridges(data = filter(preds, cogload == "load"), aes(x = .prediction, col = factor(TLC_onset)), size = 1, rel_min_height = .005) +
  geom_histogram(aes(fill = factor(TLC_onset)), alpha = .5, position = "identity", bins = 50) +
  
  scale_colour_manual(values = balanced_cols, guide = F) +
  scale_fill_manual(values = balanced_cols, guide = F) +
  coord_cartesian(xlim = c(0, 7), clip= "off") +
  theme_classic() +
  #facet_wrap(~TLC_onset, labeller = as_labeller(function(x)return(""))) +
  theme(panel.border = element_blank(), 
       panel.background = element_blank(), 
       panel.grid = element_blank(),
       strip.background = element_blank()) +
  theme_orca +
    #geom_text(data = dat_titles, aes(x = 4, y = Inf, label = label), inherit.aes = FALSE, size = ansize, vjust = 0, col = balanced_cols) +
  ylab("Density") +
  xlab(expression("TLC"["Takeover"]*" (s)")) 
  

full_pp_checks <- ggplot(balanced_data, aes(x = TLC_takeover, y = ..density..)) + 
  geom_density_ridges(data = preds, aes(x = .prediction, col = factor(cogload)), size = 1, rel_min_height = .01) +
  geom_histogram(aes(fill = factor(cogload)), alpha = .5, position = "identity", bins = 50) +
  scale_fill_manual(values = cogload_cols, labels =rev(c('SupAuto+ACMT', 'SupAuto')), guide = FALSE) +
  scale_color_manual(values = cogload_cols, labels =rev(c('SupAuto+ACMT', 'SupAuto')), guide = FALSE) +
  coord_cartesian( clip= "off") +
  theme_classic() +
  facet_wrap(~TLC_onset, labeller = as_labeller(function(x)return("")), scales = "free") +
  
  theme(panel.border = element_blank(), 
       panel.background = element_blank(), 
       panel.grid = element_blank(),
       strip.background = element_blank()) +
  theme_orca +
    geom_text(data = dat_titles, aes(x = 4, y = Inf, label = label), inherit.aes = FALSE, size = ansize, vjust = 0, col = balanced_cols) +
  ylab("Density") +
  xlab(expression("TLC"["Takeover"]*" (s)"))


leg_v = .15 #vertical spacing
leg_b = 1 #starting bottom
leg_l = 5 #left align
leg_h = .35 #space between dot and text

pp_checks_v2 <- ggplot(balanced_data, aes(x = TLC_takeover, y = ..density..)) + 
  geom_density_ridges(data = preds, aes(x = .prediction, col = factor(TLC_onset)), size = 1, rel_min_height = .005) +
  geom_histogram(aes(fill = factor(TLC_onset)), alpha = .5, position = "identity", bins = 50) +
  scale_colour_manual(values = balanced_cols, guide = F) +
  scale_fill_manual(values = balanced_cols, guide = F) +
  coord_cartesian(xlim = c(0, 7), clip= "off") +
  theme_classic() +
  facet_grid(.~cogload, labeller = labeller(cogload = cogload.names))+
  theme(panel.border = element_blank(), 
       panel.background = element_blank(), 
       panel.grid = element_blank(),
       strip.background = element_blank()) +
  theme_orca +
  #custom legend
  annotate("point", x = leg_l, y= leg_b + (5*leg_v), col = balanced_cols[1], shape = 15, size = 2) +
  annotate("text", x = leg_l+leg_h, y = leg_b + (5*leg_v), label = "2.2 s", hjust = 0, vjust = .4, size = ansize) +
  
  annotate("point", x = leg_l, y= leg_b + (4*leg_v), col = balanced_cols[2], shape = 15, size = 2) +
  annotate("text", x = leg_l+leg_h, y = leg_b + (4*leg_v), label = "3.7 s", hjust = 0, vjust = .4, size = ansize) +
  
  annotate("point", x = leg_l, y= leg_b + (3*leg_v), col = balanced_cols[3], shape = 15, size = 2) +
  annotate("text", x = leg_l+leg_h, y = leg_b + (3*leg_v), label = "7.1 s", hjust = 0, vjust = .4, size = ansize) +
  
  annotate("point", x = leg_l, y= leg_b + (2*leg_v), col = balanced_cols[4], shape = 15, size = 2) +
  annotate("text", x = leg_l+leg_h, y = leg_b + (2*leg_v), label = "9.6 s", hjust = 0, vjust = .4, size = ansize) +
  
   
  ylab("Density") +
  xlab(expression("TLC"["Takeover"]*" (s)"))

print(pp_checks_v2)

#print(full_pp_checks)

#print(noload_pp_checks)
#print(load_pp_checks)

#p_ppchecks <- plot_grid(noload_pp_checks, load_pp_checks, nrow = 2, labels = c("A","B"), label_size = 12)
#print(p_ppchecks)

ggsave("TLC_ppchecks.eps", plot = pp_checks_v2, dev = cairo_ps, width = 13.2, height = 6, units = "cm", dpi = 300)


```


```{r, functions for predicting random effect distributions, minus estimation uncertainty}

#predictive distribution of map and sigma for single row of parameters (so you can choose to include uncertainty or not)
predict_condition_dpars_fixed <- function(row, TLC_onset){
  
  
  #########
  # in the model mu and sigma are predicted independently in seperate regression models.
  # by construction all the coefficients in each model have estimated sds and correlations with one another
  # here we formulate a covariance matrix then simulate a predictive distribution of coefficients for both mu and sigma.
  
  # mu = b_Intercept + b_TLC_onset*TLC_onset + b_cogloadload * cogload + b_TLC_onset:cogloadload * TLC_onset*cogload
  
  #log(sigma) = b_sigma_Intercept + b_sigma_logTLC_onset*log(TLC_onset) + b_sigma_cogloadload*cogload
  #########
  row <- select(row, starts_with('b'))
  mu_dist <- row
  sig_dist <- row
  
    for (to in TLC_onset){
      varname <- paste(to, "load", sep="_")
    
    mu_dist[[varname]] <- with(row, b_Intercept + b_TLC_onset*to + b_cogloadload*1 + `b_TLC_onset.cogloadload`*(to*1))
    sig_dist[[varname]] <- with(row, b_sigma_Intercept + b_sigma_logTLC_onset*log(to) + b_sigma_cogloadload*1)
    
    
    varname <- paste(to, "noload", sep="_")
    mu_dist[[varname]] <- with(row, b_Intercept + b_TLC_onset*to + b_cogloadload*0 + `b_TLC_onset.cogloadload`*(to*0))
    sig_dist[[varname]] <- with(row, b_sigma_Intercept + b_sigma_logTLC_onset*log(to) + b_sigma_cogloadload*0)
  }
      
      
  mu_long <- mu_dist %>% 
    pivot_longer(-starts_with('b'),
                 names_to = c("TLC_onset","cogload"),
                 names_sep = "_",
                 values_to = "mu")
  
  sig_long <- sig_dist %>% 
    pivot_longer(-starts_with('b'),
                 names_to = c("TLC_onset","cogload"),
                 names_sep = "_",
                 values_to = "sigma")
  
  #exponentiate sigma so you can treat it as a distributional parameters henceforth
  sig_long$sigma <- exp(sig_long$sigma)

  #return here
  dpar_dists <- list(mu_long, sig_long)
  return(dpar_dists)
  
  
}


predict_coeff_dist <- function(row, nsamples){

  #########
  # in the model mu and sigma are predicted independently in seperate regression models.
  # by construction all the coefficients in each model have estimated sds and correlations with one another
  # here we formulate a covariance matrix then simulate a predictive distribution of coefficients for both mu and sigma.
  
  # mu = b_Intercept + b_TLC_onset*TLC_onset + b_cogloadload * cogload + b_TLC_onset:cogloadload * TLC_onset*cogload
  
  #log(sigma) = b_sigma_Intercept + b_sigma_logTLC_onset*log(TLC_onset) + b_sigma_cogloadload*cogload
  #########
  

  
  #### mu #####
  #intercept
  cov_int_to <- with(row, sd_ppid__Intercept*sd_ppid__TLC_onset*cor_ppid__Intercept__TLC_onset)
  cov_int_cl <- with(row, sd_ppid__Intercept*sd_ppid__cogloadload*cor_ppid__Intercept__cogloadload)
  cov_int_to.cl <- with(row, sd_ppid__Intercept*sd_ppid__TLC_onset.cogloadload*cor_ppid__Intercept__TLC_onset.cogloadload)
  
  #TLC
  cov_to_cl <- with(row,sd_ppid__TLC_onset*sd_ppid__cogloadload*cor_ppid__TLC_onset__cogloadload)
  cov_to_to.cl <- with(row,sd_ppid__TLC_onset*sd_ppid__TLC_onset.cogloadload*cor_ppid__TLC_onset__TLC_onset.cogloadload)
  
  #cl
  cov_cl_to.cl <- with(row, sd_ppid__cogloadload*sd_ppid__TLC_onset.cogloadload*cor_ppid__cogloadload__TLC_onset.cogloadload)
  
  
  cov_mat_mu = with(row, matrix(
    c(sd_ppid__Intercept^2, cov_int_to, cov_int_cl, cov_int_to.cl,
      cov_int_to, sd_ppid__TLC_onset^2, cov_to_cl, cov_to_to.cl,
      cov_int_cl, cov_to_cl, sd_ppid__cogloadload^2, cov_cl_to.cl,
      cov_int_to.cl, cov_to_to.cl, cov_cl_to.cl, sd_ppid__TLC_onset.cogloadload^2), ncol = 4))
  
  
  #print(cov_mat_mu)
  mu_dist <- as.data.frame(MASS::mvrnorm(nsamples, c(row$b_Intercept, row$b_TLC_onset, row$b_cogloadload, row$b_TLC_onset.cogloadload), cov_mat_mu))
  
  colnames(mu_dist) <- c("b_Intercept","b_TLC_onset","b_cogloadload","b_TLC_onset.cogloadload")
  mu_dist$pp <- 1:nsamples
  
  #### sigma ####
  
  #intercept
  cov_int_to <- with(row, sd_ppid__sigma_Intercept*sd_ppid__sigma_logTLC_onset*cor_ppid__sigma_Intercept__sigma_logTLC_onset)
  cov_int_cl <- with(row, sd_ppid__sigma_Intercept*sd_ppid__sigma_cogloadload*cor_ppid__sigma_Intercept__sigma_cogloadload)
  cov_to_cl <- with(row,sd_ppid__sigma_logTLC_onset*sd_ppid__sigma_cogloadload*cor_ppid__sigma_logTLC_onset__sigma_cogloadload)
  
  cov_mat_sig = with(row, matrix(
    c(sd_ppid__sigma_Intercept^2, cov_int_to, cov_int_cl, 
      cov_int_to, sd_ppid__sigma_logTLC_onset^2, cov_to_cl, 
      cov_int_cl, cov_to_cl, sd_ppid__sigma_cogloadload^2), ncol = 3))
  
  
  sig_dist <- as.data.frame(MASS::mvrnorm(nsamples, c(row$b_sigma_Intercept, row$b_sigma_logTLC_onset, row$b_sigma_cogloadload), cov_mat_sig))
  
  colnames(sig_dist) <- c("b_sigma_Intercept","b_sigma_logTLC_onset","b_sigma_cogloadload")
  sig_dist$pp <- 1:nsamples
  
  #return for two distributions here here.
  dists <- list(mu_dist, sig_dist)
  return(dists)
}
  
  
predict_condition_dpars <- function(TLC_onset, coef_dists){   
  
  mu_dist <- coef_dists[[1]]
  sig_dist <- coef_dists[[2]]
  
  for (to in TLC_onset){
    varname <- paste(to, "load", sep="_")
    
    mu_dist[[varname]] <- with(mu_dist, b_Intercept + b_TLC_onset*to + b_cogloadload*1 + `b_TLC_onset.cogloadload`*(to*1))
    sig_dist[[varname]] <- with(sig_dist, b_sigma_Intercept + b_sigma_logTLC_onset*log(to) + b_sigma_cogloadload*1)
    
    
    varname <- paste(to, "noload", sep="_")
    mu_dist[[varname]] <- with(mu_dist, b_Intercept + b_TLC_onset*to + b_cogloadload*0 + `b_TLC_onset.cogloadload`*(to*0))
    sig_dist[[varname]] <- with(sig_dist, b_sigma_Intercept + b_sigma_logTLC_onset*log(to) + b_sigma_cogloadload*0)
  }
      
      
  mu_long <- mu_dist %>% 
    pivot_longer(-c(starts_with('b'),'pp'),
                 names_to = c("TLC_onset","cogload"),
                 names_sep = "_",
                 values_to = "mu")
  
  sig_long <- sig_dist %>% 
    pivot_longer(-c(starts_with('b'),'pp'),
                 names_to = c("TLC_onset","cogload"),
                 names_sep = "_",
                 values_to = "sigma")
  
  #exponentiate sigma so you can treat it as a distributional parameters henceforth
  sig_long$sigma <- exp(sig_long$sigma)

  #return here
  dpar_dists <- list(mu_long, sig_long)
  return(dpar_dists)
}
  

simulate_TLCtakeovers <- function(dpar_dists, nobs = 10){
  #simulate participants. since mu and sigma are considered independent in the model, just randomly draw from them separately
  mu_long <- dpar_dists[[1]]
  sig_long <- dpar_dists[[2]]
  mu_long$sigma <- sig_long$sigma
  
  #for each participant you want to sample n obs at the conditions.
  obs <- rnorm(nrow(mu_long)*nobs, mu_long$mu, mu_long$sigma)
  full_df <- cbind(mu_long, matrix(obs, nrow = nrow(mu_long), byrow = FALSE))
  full_df$TLC_onset <- as.numeric(full_df$TLC_onset)
  return(full_df)
}


quantile_range <- function(full_df, quantiles){
  
  df <- full_df %>% 
    pivot_longer(matches("^[[:digit:]]+"),
                 values_to = "TLC_takeover") %>% 
    filter(TLC_takeover < TLC_onset) %>% #truncated dist
    group_by(TLC_onset, cogload) %>% 
    summarise(q1 = quantile(TLC_takeover, quantiles[1]),
              q2 = quantile(TLC_takeover, quantiles[2]),
              range95 = q2 - q1,
              stdev = sd(TLC_takeover),
              mn = mean(TLC_takeover),
              cv = stdev/mn)
  
  return(df)
}
  
  
  
  
avg_pcross <- function(dpar_dists, tt = 0){
  
  #for each participant (randomly drawn mu and sigma) calculate a pcross.
  #tt is the TLC at takeover. default is zero, meaning that they takeover precisely on the road edge so will exit the road.
  mu_long <- dpar_dists[[1]]
  sig_long <- dpar_dists[[2]]
  
  mu_long$sigma <- sig_long$sigma
  mu_long <- mu_long %>% 
    group_by(pp, TLC_onset, cogload) %>% 
    mutate(pcross = pnorm(tt, mu, sigma))
  
  
  pcross_avg <- mu_long %>% 
    ungroup() %>% 
    group_by(TLC_onset, cogload) %>% 
    summarise(pcross = mean(pcross, na.rm = TRUE))
  pcross_avg$TLC_onset <- as.double(pcross_avg$TLC_onset)
  
  return(pcross_avg)
}


simulate_pcross <- function(samples, tt = 0, TLC_onset = seq(.1, to = 20, by = .1)){
  time <- Sys.time()
  for (row in 1:nrow(samples)) {
    print(row)
    simrow <- samples[row,]
    row_dists <- predict_coeff_dist(simrow, 500) #simulate driver coefficients.
    row_dpars <- predict_condition_dpars(TLC_onset, row_dists) #simulate mean and sd for each condition predicted   from regmodel
    
    
    
    for (t in tt){
      draw <- paste0("draw",row)
      varname <- paste(draw, t, sep = "_")
      p_c <- avg_pcross(row_dpars, t) #for each condition calculate avg pcross across drivers. So, each sample has an   estimated Pcross. 
      if (row == 1){
          pc <- p_c
      }
      pc[[varname]] <- p_c$pcross
    }
  }
  print(Sys.time() - time)  
  
  pc <- pc %>% 
  pivot_longer(-c('TLC_onset','cogload','pcross'),
               names_to = c("draw","tminus"),
               names_sep = "_",
               values_to = "val")

  return(pc)
}


```

```{r, random effects plots}
twosd = .955
twosd.l = .5 - (twosd/2)
twosd.u = .5 + (twosd/2)


TLC_onset <- seq(.25, to = 15, by = .25)
#mean_censoring <- TLC_onset - (15 - avg_onset)
#censor <- data.frame(TLC_onset, mean_censoring)
#ppid <- 1:20
cogload <- c("noload","load")

pred_list <- expand_grid(TLC_onset, cogload)

#range (FIXED EFFECTS)
map_sig <- fitted(MOD, newdata=pred_list, summary=TRUE, re_formula = NA, dpar = "sigma") %>% 
  cbind(pred_list) %>% 
  mutate(range95 = Estimate*4)

#med params + Fixed effect MODEL ERROR 
pop_range <- predict(MOD, newdata=pred_list, summary=TRUE, re_formula = NA, probs = c(twosd.l, twosd.u)) %>% 
  cbind(pred_list) %>% 
  mutate(range95 = Q97.75 - Q2.25)



#range for med params FIXED + RANDOM

samples <- as.data.frame(MOD[["fit"]]@sim[["samples"]][[1]])
samples <- samples[1001:10000, ]
parmeds <- sapply(samples, median)
mymeds <- data.frame("parameters" = names(parmeds), "med" = parmeds)
med_params <- mymeds %>% 
  pivot_wider(names_from = "parameters",
              values_from = "med")

coef_dists <- predict_coeff_dist(med_params, 1000) #coefficients.
condition_dpars <- predict_condition_dpars(TLC_onset, coef_dists) #dpars predicted from regmodel
obs <- simulate_TLCtakeovers(condition_dpars, nobs = 100) 
raneff_range <- quantile_range(obs, c(twosd.l, twosd.u))


dpars_fixed <- predict_condition_dpars_fixed(med_params, TLC_onset)
sig_fixed <- dpars_fixed[[2]] %>% 
  mutate(range95 = sigma*4)
sig_fixed$TLC_onset <- as.numeric(sig_fixed$TLC_onset)
sig_fixed$mu <- dpars_fixed[[1]]$mu
sig_fixed <- sig_fixed %>% 
  mutate(cv = sigma /mu)
obs_fixed <- simulate_TLCtakeovers(dpars_fixed, nobs = 10000)
fixeff_range <- quantile_range(obs_fixed, c(twosd.l, twosd.u))
fixeff_range$TLC_onset <- as.numeric(fixeff_range$TLC_onset)


print(quantile(rnorm(10000), twosd.l))


#FULL PREDICTIVE (FIXED + RANDOM + UNCERTAINTY) 
ppid <- seq(50,100)
pred_list_new <- expand_grid(TLC_onset, cogload, ppid)

pp_range <- predict(MOD, newdata=pred_list_new, summary=FALSE, allow_new_levels = TRUE, probs = c(twosd.l, twosd.u), sample_new_levels = "gaussian", nsamples = 9000) %>% 
  t() %>% 
  cbind(pred_list_new) 
  #mutate(range95 = Q97.75 - Q2.25)

pp_quantiles <- pp_range %>% 
   pivot_longer(matches("^[[:digit:]]+"),
                 values_to = "TLC_takeover") %>% 
    group_by(TLC_onset, cogload) %>% 
    summarise(q1 = quantile(TLC_takeover, twosd.l, na.rm = TRUE),
              q2 = quantile(TLC_takeover, twosd.u, na.rm = TRUE),
              range95 = q2 - q1,
              stdev = sd(TLC_takeover, na.rm = TRUE),
              mn = mean(TLC_takeover, na.rm = TRUE),
              cv = stdev/mn)


range_plot <- ggplot(pp_quantiles, aes(x = TLC_onset, y = cv, fill = cogload, col = cogload)) +
  
  geom_area(data = pp_quantiles, col = "blue", alpha = .1) + #fully predictive (including uncertainty)
  geom_area(data = sig_fixed, col = "red", alpha = .1) + #median parameters for population within pp variability
  geom_area(data = raneff_range, col = "green", alpha = .1) + #median parameters for fixed and random
  theme_classic() +
  xlab(expression("TLC"["Failure"]*" (s)")) +
  facet_wrap(~cogload) +
  coord_cartesian(xlim = c(2,13)) +#, ylim = c(0, 10)) +
  ylab(parse(text = TeX('$\\sigma / \\mu$'))) +
    #round facet titles and place legend position
  theme(panel.border = element_blank(), 
       panel.background = element_blank(), 
       panel.grid = element_blank(),
       strip.background = element_blank(),
       legend.position = c(0.3, 0.9),
       legend.background = element_blank(),
       legend.title = element_blank(),
       legend.direction = ("horizontal")) 

print(range_plot)

ggsave("variability_stack.png", plot = range_plot, dev = "png", width = 18, height = 7, units = "cm", dpi = 300, type = "cairo")
#ggsave("variability_stack.svg", plot = range_plot, dev = "svg", width = 18, height = 7, units = "cm", dpi = 300)
ggsave("variability_stack.eps", plot = range_plot, dev = cairo_ps, width = 13.2, height = 7, units = "cm", dpi = 300)

```

```{r, variability plot take 2, fig.width= 3.42, fig.height=4.72}

print(mean(sig_fixed$range95 / pp_quantiles$range95))
print(mean(raneff_range$range95 / pp_quantiles$range95))
print(1- mean(raneff_range$range95 / pp_quantiles$range95))
print(mean(raneff_range$range95 / pp_quantiles$range95) - mean(sig_fixed$range95 / pp_quantiles$range95))

props_df <- tibble(TLC_onset = pp_quantiles$TLC_onset,
                   cogload = pp_quantiles$cogload,
                   within_pp = sig_fixed$cv,
                   between_pp = raneff_range$cv,
                   full_range = pp_quantiles$cv)

avg_cv <- pp_quantiles %>% 
  group_by(cogload) %>% 
  summarise(cvmn = mean(cv),
            sdcv = sd(cv)) 


noload_range<- filter(props_df, cogload == "noload")$full_range
props_df$noload_full <- rep(noload_range, each = 2)

#CV is unstable when mean is low, so filter from 2 TLC above
#CV is already standardised, so don't need to be a proportion of no load.
props_df <- tibble(TLC_onset = pp_quantiles$TLC_onset,
                   cogload = pp_quantiles$cogload,
                   within_pp = sig_fixed$cv,
                   between_pp = raneff_range$cv,
                   full_range = pp_quantiles$cv)

#find additive component due to each variability source
props_df <- props_df %>% 
  mutate(between_component = between_pp - within_pp,
         estimation_component = full_range - between_pp)


agg_df <- props_df %>% 
  filter(TLC_onset >= 2) %>% 
  group_by(cogload) %>% 
  summarise(within = mean(within_pp),
            between = mean(between_component),
            estimation = mean(estimation_component),
            total = within+between+estimation,
            totalmn = mean(full_range),
            totalsd = sd(full_range))%>% 
  pivot_longer(-c(cogload,total, totalmn, totalsd),
               names_to = 'component',
               values_to = 'cv') %>% 
  mutate(component = fct_relevel(component, "estimation", "between", "within"),
         inter = interaction(cogload, component)) %>% 
  mutate(pc = cv / totalmn)

prop_plot <- ggplot(data = agg_df, aes(x = rev(component), y = cv, fill = rev(cogload))) +
  geom_col(position = "dodge", width = .5, alpha =.7) +
  scale_fill_manual(values =  cogload_cols, labels = rev(c('SupAuto+ACMT', 'SupAuto')))+
  theme_classic() +
  xlab("Source of Variability") +
  #ylab(parse(text = TeX("$\\% \\, SupAuto \\, \\pm 2\\sigma \\, range$"))) +
  ylab("CV") +
  scale_y_continuous(breaks = seq(0,1, .1), label=function(x){return(x)}, ) +
  scale_x_discrete(labels = rev(c("Est", "Betw","Within"))) +
  theme_orca +
  theme(legend.title = element_blank(),
        legend.position = c(.72,.85),
        legend.direction = "vertical",
        legend.background = element_blank(),
        legend.key.size = unit(.75,"line"))

print(prop_plot)

predicted_plot <- plot_grid(pred_ribbon, prop_plot, ncol = 1, labels = c("A","B"), label_size = 12, rel_heights = c(1.5,1))
print(predicted_plot)

ggsave("predictive_intervals.eps", plot = predicted_plot, dev = cairo_ps, width = 8.7, height = 12, units = "cm", dpi = 300)

ggsave("predictive_intervals.png", plot = predicted_plot, dev = "png", width = 13.2, height = 7, units = "cm", dpi = 300, type = "cairo")
#print(effects_grid)

```



```{r, hypotheticals}
off_tangent <- function(w = 1.5, r = 60, v = 8){
  #TLC = sqrt(w*(2*r + sign(b)*w)/(abs(b)*r*v))
  TLC = sqrt(w*(2*r + w)/(v^2))
}


#for lane widths:
#https://www.standardsforhighways.co.uk/dmrb/search/66f2661f-959d-4b13-8139-92fbd491cbcf

#Traffic lane widths for horizontal curvature greater than 400 metres radii shall be in accordance with
#Figures 2.1.1N1a to 2.1.1N1h. So, curvatre > 400 will have a lane width of approximately 3.65.
#Traffic lane widths for carriageways with horizontal curve radii of greater than 90 metres but below 400
#metres are given in CD 109 [Ref 14.N].
#Traffic lane widths at junctions where the horizontal curve radii are 90 metres or less are given in CD
#123 [Ref 11.N].


#for speed and radii:
#https://www.standardsforhighways.co.uk/dmrb/search/c27c55b7-2dfc-4597-923a-4d1b4bd6c9fa

#the design speed is not actually that simple to calculate. You need a Layout constraint and alignment constraint.
#But large safe rounds will have low constraints, so we can estimate a design speed of 120 kph (3.65 m lane width).
#Single carriageways have more layout constraints (from 29 - 21 - see table 2.3). This results in a range from 85B to 100A, depending on visibility)
#hard to estimate the 'typical' single carriageway, so let's pick 100 and 85.
#This means that the design radius range from 255-2040!


#for motorways. national speed limit 70 mph (112.6 kph)
mph = c(70,70,70,70,70, 70)
kph = mph * 1.6
ms = mph /2.237
radii = c(2880, 2040, 1440, 1020, 720, 510)
yawrate = ms/radii
v2r = kph^2 / radii

motorway <- data.frame("radii" = radii, "mph" = mph, "kph" = kph, "ms" = ms, "yawrate" = yawrate, "v2r" = v2r)
motorway <- motorway %>% 
  mutate(TLC_tangent = off_tangent(w = 1.825, r = radii, v = ms))
print(motorway)

#for single lane carriageways. national speed limit 60 mph (96.6 kph)
mph = c(60,60,60,60,60, 60, 60)
kph = mph * 1.6
ms = mph /2.237
radii = c(2040, 1440, 1020, 720, 510, 360, 255) #255 is the added minimum for 85kph design.
yawrate = ms/radii
v2r = kph^2 / radii

single <- data.frame("radii" = radii, "mph" = mph, "kph" = kph, "ms" = ms, "yawrate" = yawrate, "v2r" = v2r)
single <- single %>% 
  mutate(TLC_tangent_wide = off_tangent(w = 1.825, r = radii, v = ms),
         TLC_tangent_narrow = off_tangent(w = 1.5, r = radii, v = ms),)
print(single)

#Uk standards basically range from 1-3 s TLC.
#Reasonably sharp bend, 60 mph, 500. Standard lane width (3.65 m)
mph = c(60,70)
kph = mph * 1.6
ms = mph/2.237
radii = c(500,2000)
yawrate = ms/radii
v2r = kph^2 / radii
tests <- data.frame("radii" = radii, "mph" = mph, "kph" = kph, "ms" = ms, "yawrate" = yawrate, "v2r" = v2r)
tests <- tests %>% 
  mutate(TLC_tangent_wide = off_tangent(w = 1.825, r = radii, v = ms),
         TLC_tangent_narrow = off_tangent(w = 1.5, r = radii, v = ms),)
print(tests)

#Gradual motorway, 70 mph, 1500. Standard lane width (3.65 m)
```

```{r, simulate pcross dataframe}

#These Pcross data frames take a long time to simulate. 


#prcros
#what was the minimum TLC that didn't exit the road? .15. That will be our estimate fo pcross.


#minimum TLC for nonexiters is .15 (though the exiters range from .09 - .6 TLC.)
# based on the hypothetical roads

notexit <- data_RTs_cens %>% 
  filter(maxsb < 1.5)

exited <- data_RTs_cens %>% 
  filter(maxsb > 1.5)

mean(exited$TLC_takeover, na.rm = TRUE)

if (REFIT) {
  samples <- as.data.frame(MOD[["fit"]]@sim[["samples"]][[1]])
  samples <- samples[1001:10000, ]
  pc <- simulate_pcross(samples, 0)
  save(pc, file = 'pcross.rda')  
  
  pc25 <- simulate_pcross(samples, .25)
  save(pc25, file = 'pcross25.rda')  
  
  pc50 <- simulate_pcross(samples, .5)
  save(pc50, file = 'pcross50.rda')  
  
  pc75 <- simulate_pcross(samples, .75)
  save(pc75, file = 'pcross75.rda')  
  
  pc100 <- simulate_pcross(samples, 1)
  save(pc100, file = 'pcross100.rda')  
  
  samps <- samples[1:2000,] #only a subset..
  pc_full <- simulate_pcross(samps, tt = c(0,.05,.1,.15,.2,.25,.3,.35,.4,.45,.5,.55,.6,.65,.7,.75,.8,.85,.9,.95,1,
                                           1.05,1.1,1.15,1.2,1.25,1.3,1.35,1.4,1.45,1.5), TLC_onset = c(1.6,2.7))
  save(pc_full, file = 'pcross_full.rda')  
  
  #pc50 <- simulate_pcross(samples, .5)
  #save(pc15, file = 'pcross50.rda')  
  
} else {
  load('pcross.rda')  
  load('pcross25.rda')  
  load('pcross50.rda')  
  load('pcross75.rda')
  load('pcross100.rda')
  load('pcross_full.rda')
  
}




```


```{r, pcross plot, fig.width=5.2, fig.height=2.4}

#load('pcross.rda')
onesd = .683
onesd.l = .5 - (onesd/2)
onesd.u = .5 + (onesd/2)
twosd = .955
twosd.l = .5 - (twosd/2)
twosd.u = .5 + (twosd/2)

pc_bounds <- pc50 %>% 
  ungroup() %>% 
  group_by(TLC_onset, cogload) %>% 
  summarise(Estimate = mean(val),
            Q2.25 = qi(val, .width = twosd)[1],
            Q15.85 = qi(val, .width = onesd)[1],
            Q84.15 = qi(val, .width = onesd)[2],
            Q97.75 = qi(val, .width = twosd)[2])

psim <- ggplot() +
  #geom_line(col = "blue") +
 #geom_line(data = loaddf, col = "red") +
 # geom_line(data = toplot, aes(x = TLC_onset, y =pcross, col = cogload, group = interaction(pp,cogload)), inherit.aes = FALSE, alpha = .2) +
  
  #geom_line(data = pc_avg, aes(x = TLC_onset, y =pcross, col = cogload, group = cogload), inherit.aes = FALSE, alpha = 1) +
  #geom_line(data = pc, aes(x = TLC_onset, y =val, col = cogload, group = interaction(draw,cogload)), inherit.aes = FALSE, alpha = .2) +  

    geom_line(data = pc_bounds, aes(x = TLC_onset, y =Estimate, col = cogload, group = cogload), inherit.aes = FALSE, alpha = 1, linetype = 1) +  
  
  geom_ribbon(data =pc_bounds, aes(x=TLC_onset, ymin = Q2.25, ymax = Q97.75, fill = cogload), col = NA, alpha = .1, inherit.aes = FALSE) + #99% band
  geom_ribbon(data = pc_bounds, aes(x = TLC_onset, ymin = Q15.85, ymax = Q84.15, fill = cogload), alpha = .2, inherit.aes = FALSE) + #50% band
  
  geom_vline(xintercept =  1.6, col = "grey40", linetype = 3) +
  geom_vline(xintercept = 2.7, col = "grey40", linetype = 2) +
  annotate("text", x = 2.7, y = .12, label = "Motorway Bend", hjust = .5, vjust = -.5, size = ansize, angle = -90, col = "grey40") +
  annotate("text", x = 1.6, y = .12, label = "Rural Road Bend", hjust = .5, vjust = -.5, size = ansize, angle = -90, col = "grey40") +
  
  
  theme_classic() +
  ylab("P(Exit)") +
  xlab(expression("TLC"["Failure"]*" (s)")) +
  coord_cartesian(xlim = c(.25, 10), ylim = c(0,.15)) +
  scale_y_continuous(breaks = c(0, 0.05, 0.1, 0.15), labels = c("0",".05",".1",".15")) +
  
  scale_color_manual(values = rev(cogload_cols), labels = c('SupAuto+ACMT', 'SupAuto'), guide = guide_legend(reverse = FALSE), ) + scale_fill_manual(values = rev(cogload_cols), guide = F) +
  theme(legend.position = c(.7,.9),
        legend.title = element_blank(),
        legend.background = element_blank(),
        legend.key.size = unit(.75,"line")) +
  theme_orca


show(psim)
ggsave("simulated_pcross.png", plot = psim, dev = "png", width = 13.2, height = 6, units = "cm", dpi = 300, type = "cairo")

ggsave("simulated_pcross.eps", plot = psim, dev = cairo_ps, width = 13.2, height = 6, units = "cm", dpi = 300)
```

```{r, plotting p_full, fig.width= 3.42, fig.height=4.33}

onesd = .683
onesd.l = .5 - (onesd/2)
onesd.u = .5 + (onesd/2)
twosd = .955
twosd.l = .5 - (twosd/2)
twosd.u = .5 + (twosd/2)

pc_bounds_full <- pc_full %>% 
  ungroup() %>% 
  group_by(TLC_onset, cogload, tminus) %>% 
  summarise(Estimate = mean(val),
            Q2.25 = qi(val, .width = twosd)[1],
            Q15.85 = qi(val, .width = onesd)[1],
            Q84.15 = qi(val, .width = onesd)[2],
            Q97.75 = qi(val, .width = twosd)[2])
mydelay = .5


p_delay <- ggplot(pc_bounds_full, aes(x = as.numeric(tminus), col = factor(cogload), y = Estimate, group = cogload)) +
  geom_line(data = filter(pc_bounds_full, TLC_onset == 1.6), linetype = 3) +
  geom_line(data = filter(pc_bounds_full, TLC_onset == 2.7), linetype = 2) +
  scale_color_manual(values = rev(cogload_cols), labels = c('SupAuto+ACMT', 'SupAuto'), guide = FALSE) +
  theme_classic() +
  theme_orca +
  expand_limits(y= 1)+
  coord_cartesian(x = c(0,1.5)) +
  #scale_x_continuous(breaks = c(0, 0.5, 1), labels = c("0",".5", "1")) +
  ##scale_x_continuous(breaks = c(0, 0.25, 0.5, 0.75, 1, 1.25,1.5), labels = c("0",".25",".5",".75", "1")) +
  geom_vline(xintercept = mydelay, col = "grey80") +
  annotate("text", x = mydelay, y = .6, label = "Delay used for predictions", hjust = .5, vjust = -0.5, size =
6/text_multiplier, angle = -90, col = "grey80") +
    annotate("text", x = .9, y = .7, label = "Rural", hjust = .5, vjust = -.5, size = 6/text_multiplier, angle = 50, col = "grey40") +
      annotate("text", x = 1.1, y = .41, label = "Motorway", hjust = .5, vjust = -.7, size = 6/text_multiplier, angle = 40, col = "grey40") +
  ylab("P(Exit)") +
  xlab("Additional Delay (s)") +
  theme(legend.position = c(.7,.9),
        legend.title = element_blank(),
        legend.background = element_blank(),
        legend.key.size = unit(.75,"line")) 
  

print(p_delay)

p_applied <- plot_grid(psim, p_delay, labels = c("A","B"), label_size = 12, ncol = 1, rel_heights = c(1.25,1))
show(p_applied)

ggsave("p_applied.png", plot = p_applied, dev = "png", width = 8.7, height = 11, units = "cm", dpi = 300, type = "cairo")

ggsave("p_applied.eps", plot = p_applied, dev = cairo_ps, width = 8.7, height = 11, units = "cm", dpi = 300)

```

```{r, appendix psim, fig.width=7, fig.height=4}

plot_psim <- function(psim){
  
  pc_bounds <- psim %>% 
        ungroup() %>% 
  group_by(TLC_onset, cogload) %>% 
  summarise(Estimate = mean(val),
            Q2.25 = qi(val, .width = twosd)[1],
            Q15.85 = qi(val, .width = onesd)[1],
            Q84.15 = qi(val, .width = onesd)[2],
            Q97.75 = qi(val, .width = twosd)[2])

  p <- ggplot() +
    geom_line(data = pc_bounds, aes(x = TLC_onset, y =Estimate, col = cogload, group = cogload), inherit.aes = FALSE, alpha = 1, linetype = 1) +  
  geom_ribbon(data =pc_bounds, aes(x=TLC_onset, ymin = Q2.25, ymax = Q97.75, fill = cogload), col = NA, alpha = .1, inherit.aes = FALSE) +
  geom_ribbon(data = pc_bounds, aes(x = TLC_onset, ymin = Q15.85, ymax = Q84.15, fill = cogload), alpha = .2, inherit.aes = FALSE) +
  theme_classic() +
  ylab("P(Exit)") +
  xlab(expression("TLC"["Failure"]*" (s)")) +
  coord_cartesian(xlim = c(.25, 10), ylim = c(0,.25)) +
  #scale_y_continuous(breaks = c(0, 0.05, 0.1, 0.15), labels = c("0",".05",".1",".15")) +
  scale_color_manual(values = rev(cogload_cols), labels = c('SupAuto+ACMT', 'SupAuto'), guide = guide_legend(reverse = FALSE), ) + scale_fill_manual(values = rev(cogload_cols), guide = F) +
  theme(legend.title = element_blank(),
        legend.background = element_blank()) +
  theme_orca
  return (p)
}


psims <- list(pc,pc25,pc50,pc75,pc100)
plots <- lapply(psims, plot_psim)
legend <- get_legend(
  plots[[1]] 
)

p_appendix <- plot_grid(plots[[1]] + theme(legend.position = "none"),
                        plots[[2]] + theme(legend.position = "none"), 
                        plots[[3]] + theme(legend.position = "none"), 
                        plots[[4]]+ theme(legend.position = "none"), 
                        plots[[5]] + theme(legend.position = "none"), 
                        legend,
                        labels = c("0 s",".25 s",".5 s",".75 s","1 s"), 
                        label_size = 12, label_x = .7, label_y = .95, nrow = 2)



print(p_appendix)





ggsave("p_sim_appendix.eps", plot = p_appendix, dev = cairo_ps, width = 17.8, height = 10, units = "cm", dpi = 300)

```


