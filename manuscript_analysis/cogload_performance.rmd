---
title: "Looking at Cognitive Load performance"
output:
  html_document:
    df_print: paged
  html_notebook: default
  pdf_document: default
---

## Loading the Data 

First, we want to add the files into one big data frame. For each participant we have two files. One 'EndofTrial' file that records counts, and one 'WithinTrial' file that records responses to stimuli.


```{r, echo=TRUE, message=FALSE}

library("tidyverse") #load code libraries for analysis

FilePath <- "F:/Orca_rerun_steering/" #filepath)
text_multiplier <- ggplot2:::.pt
ansize = 8/text_multiplier

```

```{r, wit df}

wit_pattern = "Orca19_.+\\d*_\\d*_WithinTrial.csv"
wit_files <- list.files(path = FilePath, pattern = wit_pattern, recursive = TRUE)

wit_files <- grep("pilot", wit_files, ignore.case = TRUE, invert = TRUE, value = TRUE)
wit_files <- grep("prac", wit_files, ignore.case = TRUE, invert = TRUE, value = TRUE)

wit_df = data.frame()

for (file in wit_files){
  
  newdata = read.csv(paste0(FilePath,file))
  current_ppid <- as.integer(substr(strsplit(file, "/")[[1]][1], start = 2, stop = 10))
  
  if (grepl("Middle", file)){
    block = 3 
    newdata$ppid = current_ppid #bug and all ppids of this file are set to 1
  } else {
    splt <- strsplit(file, "_")
    block = as.integer(splt[[1]][5])
  }  
  
  newdata$block = block
  
  #pp 3 has a different number of columns  
  if (first(newdata$ppid)==3){
    newdata$timestamp_exp <- NaN
    newdata$item_delay <- NaN
    newdata$currentaudio_type <- NaN
  }
  
  if (length(wit_df) == 0){
      wit_df <- newdata
  } else{
      wit_df <- rbind(wit_df, newdata) #add to existing datframe 
  }  
  
}

head(wit_df)
```

```{r, eot df}

eot_pattern = "Orca19_.+\\d*_\\d*_EndofTrial.csv"
eot_files <- list.files(path = FilePath, pattern = eot_pattern, recursive = TRUE)

eot_files <- grep("pilot", eot_files, ignore.case = TRUE, invert = TRUE, value = TRUE)
eot_files <- grep("prac", eot_files, ignore.case = TRUE, invert = TRUE, value = TRUE)

print(eot_files)

eot_df = data.frame()

for (file in eot_files){
  
  newdata = read.csv(paste0(FilePath,file))
  current_ppid <- as.integer(substr(strsplit(file, "/")[[1]][1], start = 2, stop = 10))
  
  if (grepl("Middle", file)){
    block = 3 
    newdata$ppid = current_ppid #bug and all ppids of this file are set to 1
  } else {
    splt <- strsplit(file, "_")
    block = as.integer(splt[[1]][5])
  }  
  
  newdata$block = block
  
  if (length(wit_df) == 0){
      eot_df <- newdata
  } else{
      eot_df <- rbind(eot_df, newdata) #add to existing datframe 
  }  
  
}

head(eot_df)
```


You can see that we have two data frames. 

The first, __EoT_dataframe__ has 12 columns. Each row is a trial (_trialn_) . The first column _X_ is the data frame index so each row has a unique identifier. The next four columns (_ppid, targetoccurence, targetnumber, trialn_) contains all the information necessary for that particular trial. The last three rows (_EoTScore1, TargetCount1...EoTScore3, TargetCount3_) contains the user inputted scores, and the actual target counts for each target. NA is inputted to any cells of trials that had fewer targets than three. 

The second dataframe, __WiT_dataframe__, also has 12 columns. Here each row is a stimulus presentation. The first five columns are the same as __EoT_dataframe__. _CurrentAudio_ is the heard stimulus. _RT_ is the response time (-1 if not responded). _ResponseCategory_ is a code for how appropriate the response is: 1 = true positive, 2 = false negative, 3 = false positive, 4 =  true negative. _Target1...Target3_ indicates the actual targets for that trial. 

Let's save these files so we don't have to load them again.


## Calculating Measures

The dataframes now hold all the data needed for calculating measures for each trial.

The experiment design allows many ways to capture performance. There are three obvious ways of measures performance: the speed of response, whether the participant responded appropriately, and how far off they were in their recorded target counts.

From the __WiT_dataframe__ the following measures need to be calculated:   
1. MeanRT_TruePos (MeanRT for True Positives)   
2. StdRT_TruePos (Standard deviation of RT for True Positives)   
3. Perc_Correct (True Positives and True Negatives)   

First, we want to remove any RTs that are unfeasibly quick, since they are probably responding to the previously head stimuli. Based on Luce (1986), this value is set at 100ms.

```{r}

wit_df <- wit_df %>% 
  mutate(trialid = paste(ppid, "Middle", trialn, sep = "_"))

wit_filtered <- filter(wit_df, RT == -1 | RT >.1) # Returns dataframe for rows where RT was >.1 or -1 (no response) 
```


```{r}
  
wit_tp <- filter(wit_filtered, ResponseCategory == 1) #create new dataframe only including true positives
  
SummaryRTs <- wit_tp %>% group_by(ppid, block, trialn) %>% summarise(
  targetnumber = first(targetnumber),
  targetoccurence = first(targetoccurence),
  meanRT = mean(RT),
  stdRT = sd(RT))

head(SummaryRTs) #view start of dataframe. For every participant and trial there will be a meanRT and a stdRT. stdRT is sometimes NA when there is only one True Positive for that trial. The trial will be missing if there are no True Positives for that trial. 

```

All the response categories are needed for calculating Perc_Correct, not just the True Positives.

```{r}

#Calculate the amount of each type of responses
SummaryCounts <- wit_filtered %>% group_by(ppid, block, trialn) %>% summarise(
  targetnumber = first(targetnumber),
  targetoccurence = first(targetoccurence),
  TruePos = sum(ResponseCategory==1),
  FalseNeg = sum(ResponseCategory==2), 
  FalsePos = sum(ResponseCategory==3),
  TrueNeg = sum(ResponseCategory==4), 
  TotalResponses=n())

#add an extra column with Perc_Correct.
SummaryCounts <- mutate(SummaryCounts, Perc_Correct = (TruePos + TrueNeg)/ TotalResponses)

```

```{r, pc correct}

ggplot(SummaryCounts, aes(x = Perc_Correct, group = factor(block), fill = factor(block))) + geom_histogram(position="identity", bins = 30, alpha = .5)


SummaryCounts %>% 
  group_by(ppid, block) %>% 
  summarise(mn_pc = mean(Perc_Correct)) %>% 
  ungroup() %>% 
  group_by(block) %>% 
  summarise(mean_pc = mean(mn_pc),
            sd_pc = sd(mn_pc))

ppid_pcs <- SummaryCounts %>% 
  filter(block == 3) %>% 
  group_by(ppid) %>% 
  summarise(mn_pc = mean(Perc_Correct))

SummaryRTs %>% 
  group_by(ppid, block) %>% 
  summarise(mn_rt = mean(meanRT, na.rm = TRUE)) %>% 
  ungroup() %>% 
  group_by(block) %>% 
  summarise(mean_rt = mean(mn_rt),
            sd_rt = sd(mn_rt))

ppid_rts <- SummaryRTs %>% 
  filter(block == 3) %>% 
  group_by(ppid) %>% 
  summarise(mn_rt = mean(meanRT, na.rm = TRUE))



```


```{r, load steering measures}

setwd("C:/git_repos/Orca18_Analysis/Post-Processing/")

#load steergaze data


#steergazedata <- read_csv("../Data/Orca19_collated_steering.csv")  
#saveRDS(steergazedata, "../Data/Orca19_collated_steering.rds")
steergazedata <- readRDS("../Data/Orca19_collated_steering.rds")  

steergazedata <- steergazedata %>% 
  mutate(trialid = paste(ppid, cogload, trialn, sep = "_"))

disengage_RT <- function(onsettime, timestamp_trial, autoflag){
  
  #pick first frame where autoflag == false, then take the timestamp and minus the onset_time
  auto_false <- which(autoflag == "FALSE")
  disengage_index <- first(auto_false)
  disengage_trialtime <- timestamp_trial[disengage_index]
  onset_time <- first(onsettime)
  RT <- disengage_trialtime - onset_time #can be negative
  return(RT)
  
}

steergazedata <- steergazedata  %>% 
  group_by(ppid, sab, cogload, trialn) %>% 
  mutate(RT = disengage_RT(onsettime, timestamp_trial, autoflag),
         disengaged = ifelse(is.na(RT), 0, 1) #whether or not they actually took over.
  )


#mirror data
steergazedata <- steergazedata %>% 
  mutate(sb_mirrored = if_else(bend == -1, steeringbias * -1, steeringbias))

steergazedata <- filter(steergazedata, cogload == "Middle")

sb_summary <- steergazedata %>% 
  group_by(trialid) %>% 
  summarise(maxsb = max(abs(sb_mirrored)),
            ppid = first(ppid)) %>% 
  ungroup() %>% 
  group_by(ppid) %>% 
  summarise(mn_maxsb = mean(maxsb))

rt_summary <- steergazedata %>% 
  group_by(trialid) %>% 
  summarise(RT = first(RT),
            ppid = first(ppid)) %>% 
  ungroup() %>% 
  group_by(ppid) %>% 
  summarise(mn_RT = mean(RT, na.rm = TRUE))


```

```{r, tradeoff}

ppid_pcs <- left_join(ppid_pcs, sb_summary, by = "ppid")
ppid_pcs <- left_join(ppid_pcs, rt_summary, by = "ppid")
ppid_rts <- left_join(ppid_rts, sb_summary, by = "ppid")
ppid_rts <- left_join(ppid_rts, rt_summary, by = "ppid")


ggplot(ppid_pcs, aes(x = mn_maxsb, y = mn_pc)) + geom_point()
ggplot(ppid_pcs, aes(x = mn_RT, y = mn_pc)) + geom_point()
ggplot(ppid_rts, aes(x = mn_maxsb, y = mn_rt)) + geom_point()
ggplot(ppid_rts, aes(x = mn_RT, y = mn_rt)) + geom_point()


cor(ppid_pcs$mn_pc, ppid_pcs$mn_maxsb)
cor(ppid_pcs$mn_pc, ppid_pcs$mn_RT)
cor(ppid_rts$mn_rt, ppid_rts$mn_maxsb)
cor(ppid_rts$mn_rt, ppid_rts$mn_RT)


```

```{r, methods fig, trial sequence, fig.height = 2, fig.width=5.2}

library(RColorBrewer)
cols <- brewer.pal(6, "Paired")[3:6]


#pick trial
trialids <- wit_df %>%
  filter(ppid > 3, block == 3) %>% 
  select(trialid) %>% 
  unique(.) 
  
trial <- sample(trialids$trialid,1)


trial_cog <- filter(wit_df, trialid == trial)
trial_cog <- trial_cog %>% 
  mutate(CurrentAudio = toupper(CurrentAudio))
targets <- filter(trial_cog, currentaudio_type == "T")
distractors <- filter(trial_cog, currentaudio_type == "D")
trial_steer <- filter(steergazedata, trialid == trial)
head(trial_cog)

takeover_frame <-  trial_steer[first(which(trial_steer$autoflag == "FALSE")),]
onset_frame <- (filter(trial_steer, timestamp_trial > first(trial_steer$onsettime)))[1,]
first_frame <- trial_steer[1,]
time_axis <- data.frame(ts = seq.int(0, 15), ts_exp = seq.int(0,15) + first_frame$timestamp_exp)

head(onset_frame)
head(trial_cog)
head(trial_steer)

t_y = .75

leg_v = .22 #vertical spacing
leg_t = -.7 #starting top
leg_l = first_frame$timestamp_exp+13 #left align
leg_h = .32 #space between dot and text
leg_t1 = -.5 #starting top
leg_l1 = first_frame$timestamp_exp+.5

p_timings <- ggplot(trial_steer, aes(x = timestamp_exp, y = sb_mirrored)) + 
  
  
  
  #labels
  geom_text(data = onset_frame, aes( x = timestamp_exp - 1, y = sb_mirrored - .8, label = "Failure onset"), size = ansize) +
  geom_segment(data = onset_frame, aes(x = timestamp_exp - 1, xend = timestamp_exp - .1, y = sb_mirrored -.7, yend = sb_mirrored - .1), colour = "black", size=.75, alpha=1, arrow=arrow(angle = 20, length = unit(0.1, "cm"), type = "closed")) +
  geom_text(data = takeover_frame, aes( x = timestamp_exp - 1, y = sb_mirrored - .6, label = "Takeover"), size = ansize) +
  geom_segment(data = takeover_frame, aes(x = timestamp_exp - 1, xend = timestamp_exp - .1, y = sb_mirrored - .5, yend = sb_mirrored - .1), colour = "black", size=.75, alpha=1, arrow=arrow(angle = 20, length = unit(0.1, "cm"), type = "closed")) +
  
  
  
  #cogtask
  geom_segment(data = targets, aes(x = timestamp_exp, xend = timestamp_exp, y = 0, yend = t_y), col = "grey40") +
  geom_segment(data = filter(targets, ResponseCategory == 1), aes(x = timestamp_exp, xend = timestamp_exp + RT, y = t_y, yend = t_y), linetype = "dotted", col = "grey40") +
  geom_point(data = filter(targets, ResponseCategory == 1), aes(x = timestamp_exp + RT, y = t_y), col = "#33A02C") +
  geom_segment(data = filter(targets, ResponseCategory == 1), aes(x = timestamp_exp + RT, xend = timestamp_exp + RT, y = 0, yend = t_y), col = "#33A02C") +
  geom_text(data = targets, aes(x = timestamp_exp, y = t_y+.15, label = CurrentAudio), size = ansize, col = "grey40") +
  geom_segment(data = distractors, aes(x = timestamp_exp, xend = timestamp_exp, y = 0, yend = .5), col = "grey60", linetype = "dashed") + 
  geom_text(data = distractors, aes(x = timestamp_exp, y = .65, label = CurrentAudio), size = ansize, col = "grey60") +
  
  scale_color_manual(values = c("TRUE" = cols[4], "FALSE" = cols[3])) +
  guides(col = FALSE) +
  
  
  #time axis
  geom_line(data = time_axis, aes(x = ts_exp, y = 0)) +
  geom_point(data = time_axis[1,], aes(x = ts_exp, y = 0), size = 2) +
  geom_point(data = tail(time_axis,1), aes(x = ts_exp, y = 0), size = 2) +
  geom_text(data = tail(time_axis,1), aes(x = ts_exp, y = -.2, label = paste0(ts, " s")), size = ansize) +
  geom_text(data = head(time_axis,1), aes(x = ts_exp, y = -.2, label = paste0(ts, " s")), size = ansize) +
  geom_segment(data = time_axis, aes(x = ts_exp, y = 0, xend = ts_exp, yend = .05)) +
  
  #steering signal
  geom_path(aes(group = autoflag, col = autoflag)) +
  geom_point(data = onset_frame, col = "black") +
  geom_point(data = takeover_frame, col = "black") +
  coord_cartesian(ylim = c(-1.5,1.5)) +
  theme_classic() +
  

  #custom legend
  annotate("segment", x = leg_l1-leg_h, xend = leg_l1, y= leg_t1, yend = leg_t1, col = "grey60", linetype = "dashed") +
  annotate("text", x = leg_l1+leg_h, y = leg_t1, label = "Distractors", hjust = 0, vjust = .5, size = ansize) +
  
  annotate("segment", x = leg_l1-leg_h, xend = leg_l1, y= leg_t1 - (leg_v), yend = leg_t1 - (leg_v), col = "grey40") +
  annotate("text", x = leg_l1+leg_h, y = leg_t1 - (leg_v), label = "Targets", hjust = 0, vjust = .5, size = ansize) +
  
  annotate("point", x = leg_l1-(leg_h/2), y= leg_t1 - (2*leg_v), col = "green3") +
  annotate("text", x = leg_l1+leg_h, y = leg_t1 - (2*leg_v), label = "Button Press", hjust = 0, vjust = .5, size = ansize) +

  annotate("segment", x = leg_l-leg_h, xend = leg_l, y= leg_t, yend = leg_t, col = cols[4]) +
  annotate("text", x = leg_l+leg_h, y = leg_t, label = "Automation", hjust = 0, vjust = .5, size = ansize) +
    
    annotate("segment", x = leg_l-leg_h, xend = leg_l, y= leg_t - (1*leg_v), yend = leg_t - (1*leg_v), col = cols[3]) +
  annotate("text", x = leg_l+leg_h, y = leg_t - (1*leg_v), label = "Manual", hjust = 0, vjust = .5, size = ansize) +

  #remove axis 
  theme(axis.ticks = element_blank(),
        axis.line = element_blank(),
        axis.text = element_blank(),
        axis.title = element_blank())
  
print(p_timings)
ggsave("p_methods_timings.eps", plot = p_timings, dev = cairo_ps, width = 13.2, height = 5, units = "cm", dpi = 300)

```



```{r, eval = FALSE}

#First, replace NA with Zeros for the following code to work. This means I can use the same code on all trials, even though some may have different amounts of targets.
eot_df[is.na(eot_df)] <- 0

#Calculate the error for each target.
eot_df <- mutate(eot_df, 
                        Error1 = EoTScore1 - TargetCount1,
                        Error2 = EoTScore2 - TargetCount2)

#Calculate the total absolute error and divide by targetnumber
eot_df <- mutate(eot_df, AvgCountError = (abs(Error1) + abs(Error2)) / targetnumber)


```


